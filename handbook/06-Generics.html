<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>六、泛型 | TypeScript手册</title>
    <meta name="description" content="TypeScript 学习手册">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/ts-translate/assets/css/0.styles.0a5bcfed.css" as="style"><link rel="preload" href="/ts-translate/assets/js/app.141fbb0f.js" as="script"><link rel="preload" href="/ts-translate/assets/js/2.a069a211.js" as="script"><link rel="preload" href="/ts-translate/assets/js/23.9732edd0.js" as="script"><link rel="prefetch" href="/ts-translate/assets/js/10.06950121.js"><link rel="prefetch" href="/ts-translate/assets/js/11.6381239b.js"><link rel="prefetch" href="/ts-translate/assets/js/12.8176b810.js"><link rel="prefetch" href="/ts-translate/assets/js/13.0a03fbf3.js"><link rel="prefetch" href="/ts-translate/assets/js/14.3482aea1.js"><link rel="prefetch" href="/ts-translate/assets/js/15.7831b050.js"><link rel="prefetch" href="/ts-translate/assets/js/16.2e5641fb.js"><link rel="prefetch" href="/ts-translate/assets/js/17.caa1f0c3.js"><link rel="prefetch" href="/ts-translate/assets/js/18.33f52e19.js"><link rel="prefetch" href="/ts-translate/assets/js/19.8756dd76.js"><link rel="prefetch" href="/ts-translate/assets/js/20.cfed5059.js"><link rel="prefetch" href="/ts-translate/assets/js/21.090f26df.js"><link rel="prefetch" href="/ts-translate/assets/js/22.ff9d5ff1.js"><link rel="prefetch" href="/ts-translate/assets/js/24.0ce34daf.js"><link rel="prefetch" href="/ts-translate/assets/js/25.240c5ec5.js"><link rel="prefetch" href="/ts-translate/assets/js/26.ece5b4f8.js"><link rel="prefetch" href="/ts-translate/assets/js/27.5cea32b1.js"><link rel="prefetch" href="/ts-translate/assets/js/28.4984b1b2.js"><link rel="prefetch" href="/ts-translate/assets/js/29.6cbf69a3.js"><link rel="prefetch" href="/ts-translate/assets/js/3.572305aa.js"><link rel="prefetch" href="/ts-translate/assets/js/30.21d3e389.js"><link rel="prefetch" href="/ts-translate/assets/js/31.e611e503.js"><link rel="prefetch" href="/ts-translate/assets/js/32.5d9d0c75.js"><link rel="prefetch" href="/ts-translate/assets/js/33.2cb939dd.js"><link rel="prefetch" href="/ts-translate/assets/js/34.f373a061.js"><link rel="prefetch" href="/ts-translate/assets/js/35.9d601f8b.js"><link rel="prefetch" href="/ts-translate/assets/js/36.45e2645f.js"><link rel="prefetch" href="/ts-translate/assets/js/37.ec9011fa.js"><link rel="prefetch" href="/ts-translate/assets/js/38.ecaf875b.js"><link rel="prefetch" href="/ts-translate/assets/js/39.79652b75.js"><link rel="prefetch" href="/ts-translate/assets/js/4.202d41bd.js"><link rel="prefetch" href="/ts-translate/assets/js/40.dfeb8b60.js"><link rel="prefetch" href="/ts-translate/assets/js/41.19371e04.js"><link rel="prefetch" href="/ts-translate/assets/js/42.12a43247.js"><link rel="prefetch" href="/ts-translate/assets/js/43.08babc31.js"><link rel="prefetch" href="/ts-translate/assets/js/5.7ad19b7d.js"><link rel="prefetch" href="/ts-translate/assets/js/6.f507dfa3.js"><link rel="prefetch" href="/ts-translate/assets/js/7.61be865b.js"><link rel="prefetch" href="/ts-translate/assets/js/8.b7b7c55c.js"><link rel="prefetch" href="/ts-translate/assets/js/9.59f9442d.js">
    <link rel="stylesheet" href="/ts-translate/assets/css/0.styles.0a5bcfed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ts-translate/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript手册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/ts-translate/handbook/01-Basic.html" class="sidebar-link">一、基本类型</a></li><li><a href="/ts-translate/handbook/02-VariableDecorations.html" class="sidebar-link">二、变量声明</a></li><li><a href="/ts-translate/handbook/03-Interface.html" class="sidebar-link">三、Interface 接口</a></li><li><a href="/ts-translate/handbook/04-Class.html" class="sidebar-link">四、类</a></li><li><a href="/ts-translate/handbook/05-Function.html" class="sidebar-link">五、函数</a></li><li><a href="/ts-translate/handbook/06-Generics.html" class="active sidebar-link">六、泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ts-translate/handbook/06-Generics.html#hello-world-of-generics" class="sidebar-link">Hello World of Generics</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/06-Generics.html#working-with-generic-type-variables" class="sidebar-link">Working with Generic Type Variables</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/06-Generics.html#generic-types" class="sidebar-link">Generic Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/06-Generics.html#generic-classes" class="sidebar-link">Generic Classes</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/06-Generics.html#generic-constraints" class="sidebar-link">Generic Constraints</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/06-Generics.html#using-type-parameters-in-generic-constraints" class="sidebar-link">Using Type Parameters in Generic Constraints</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/06-Generics.html#using-class-types-in-generics" class="sidebar-link">Using Class Types in Generics</a></li></ul></li><li><a href="/ts-translate/handbook/07-Enums.html" class="sidebar-link">七、枚举</a></li><li><a href="/ts-translate/handbook/08-TypeInference.html" class="sidebar-link">八、类型引用</a></li><li><a href="/ts-translate/handbook/09-TypeCompatibility.html" class="sidebar-link">九、兼容性</a></li><li><a href="/ts-translate/handbook/10-AdvanceTypes.html" class="sidebar-link">十、增强类型</a></li><li><a href="/ts-translate/handbook/11-Symbols.html" class="sidebar-link">十一、Symbol</a></li><li><a href="/ts-translate/handbook/12-IteratorAndGenerators.html" class="sidebar-link">十二、可迭代性 Iterables</a></li><li><a href="/ts-translate/handbook/13-Modules.html" class="sidebar-link">十三、模块</a></li><li><a href="/ts-translate/handbook/14-Namespaces.html" class="sidebar-link">十四、命名空间</a></li><li><a href="/ts-translate/handbook/15-NameSpacesModules.html" class="sidebar-link">十五、命名空间与模块</a></li><li><a href="/ts-translate/handbook/16-ModulesResolution.html" class="sidebar-link">十六、模块解析</a></li><li><a href="/ts-translate/handbook/17-DelarationMerging.html" class="sidebar-link">十七、声明合并</a></li><li><a href="/ts-translate/handbook/18-JSX.html" class="sidebar-link">十八、JSX</a></li><li><a href="/ts-translate/handbook/19-Decorators.html" class="sidebar-link">十九、修饰器</a></li><li><a href="/ts-translate/handbook/20-Mixins.html" class="sidebar-link">二十、混入</a></li><li><a href="/ts-translate/handbook/21-TripleSlashDirectives.html" class="sidebar-link">二十一、三斜线指令</a></li><li><a href="/ts-translate/handbook/22-JSDocSupportedTypes.html" class="sidebar-link">二十二、类型检查JavaScript文件</a></li><li><a href="/ts-translate/handbook/23-UtilityTypes.html" class="sidebar-link">二十三、联合类型</a></li><li><a href="/ts-translate/handbook/24-TypescriptIgnore.html" class="sidebar-link">二十四、TypeScript 类型忽略</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="六、泛型"><a href="#六、泛型" class="header-anchor">#</a> 六、泛型</h1> <p>软件工程的主要部分是构建不仅具有良好定义和一致的API，而且还可以重用的组件。
能够处理当今和未来数据的组件将为您提供构建大型软件系统的最灵活功能。</p> <p>在诸如C＃和Java之类的语言中，用于创建可重用组件的工具箱中的主要工具之一是<em>泛型</em>，也就是说，能够创建可以在多种类型而不是单个类型上工作的组件。
这使用户可以使用这些组件并使用自己的类型。</p> <h2 id="hello-world-of-generics"><a href="#hello-world-of-generics" class="header-anchor">#</a> Hello World of Generics</h2> <p>首先，让我们做一下泛型的“ hello world”：身份函数。
身份函数是一个将返回传入内容的函数。
您可以通过类似于<code>echo</code>命令的方式来考虑这一点。</p> <p>如果没有泛型，我们要么必须给标识函数一个特定的类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Or, we could describe the identity function using the <code>any</code> type:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虽然使用any无疑是通用的，因为它将导致函数接受arg类型的任何类型和所有类型，但实际上，我们丢失了有关函数返回时该类型的信息。
如果我们传入一个数字，则唯一的信息就是可以返回任何类型。</p> <p>相反，我们需要一种捕获参数类型的方式，以便我们也可以使用它来表示返回的内容。
在这里，我们将使用<em>类型变量</em>，这是一种特殊的变量，适用于类型而不是值。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，我们向身份函数添加了类型变量“ T”。
这个“ T”允许我们捕获用户提供的类型（例如“ number”），以便我们以后可以使用该信息。
在这里，我们再次使用<code>T</code>作为返回类型。通过检查，我们现在可以看到参数和返回类型使用相同的类型。
这使我们能够将键入信息的信息投放到函数的一侧，而另一端则从其中流出。</p> <p>我们说这个<code>identity</code>函数的版本是通用的，因为它适用于多种类型。
与使用“ any”不同，它与第一个使用数字作为参数和返回类型的“ identity”函数一样精确（即，它不会丢失任何信息）。</p> <p>一旦编写了通用标识函数，就可以用以下两种方法之一来调用它。
第一种方法是将所有参数（包括类型参数）传递给函数：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> output <span class="token operator">=</span> identity<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">&quot;myString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// type of output will be 'string'</span>
</code></pre></div><p>在这里，我们显式地将T设置为字符串，作为函数调用的参数之一，在参数周围而不是在（）处使用&lt;&gt;表示。</p> <p>第二种方法也许也是最常见的。这里我们使用* type参数推断*-也就是说，我们希望编译器根据传入的参数类型自动为我们设置<code>T</code>的值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token string">&quot;myString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// type of output will be 'string'</span>
</code></pre></div><p>注意，我们不必在尖括号（<code>&lt;&gt;</code>）中显式传递类型。编译器仅查看值“ myString”，并将“ T”设置为其类型。
尽管类型实参推断是使代码更短，更易读的有用工具，但是当编译器无法推断类型时，您可能需要像上一示例中那样显式传递类型实参，这可能在更复杂的示例中发生。</p> <h2 id="working-with-generic-type-variables"><a href="#working-with-generic-type-variables" class="header-anchor">#</a> Working with Generic Type Variables</h2> <p>当您开始使用泛型时，您会注意到，当您创建诸如<code>identity</code>之类的泛型函数时，编译器将强制您正确使用函数主体中的任何泛型类型的参数。
也就是说，您实际上将这些参数视为可以是任何和所有类型。</p> <p>让我们使用前面的<code>identity</code>函数：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果我们还希望每次调用时都将参数arg的长度记录到控制台，该怎么办？
我们可能会这样写：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error: T doesn't have .length</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当我们这样做时，编译器会给我们一个错误，因为我们正在使用arg的.length成员，但是我们从没有说过arg拥有这个成员。
记住，我们之前说过，这些类型变量代表所有类型，所以使用此函数的人可能会传入一个数字，而没有.length成员。</p> <p>假设我们实际上已经打算将此函数用于<code>T</code>的数组，而不是直接对<code>T</code>的数组。由于我们正在处理数组，因此.length成员应该可用。
我们可以像创建其他类型的数组那样描述它：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Array has a .length, so no more error</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>您可以将<code>loggingIdentity</code>的类型读取为“通用函数<code>loggingIdentity</code>接受类型参数<code>T</code>和参数<code>arg</code>，它是<code>T</code>s的数组，并返回<code>T</code>s的数组”。
如果我们传入一个数字数组，我们将得到一个数字数组，因为“ T”将绑定到“ number”。
这使我们可以将通用类型变量“ T”用作正在使用的类型的一部分，而不是整个类型，从而为我们提供了更大的灵活性。</p> <p>我们可以选择以这种方式编写示例示例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Array has a .length, so no more error</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>您可能已经从其他语言中熟悉了这种类型的字体。
在下一节中，我们将介绍如何创建自己的通用类型，例如<code>Array &lt;T&gt;</code>。</p> <h2 id="generic-types"><a href="#generic-types" class="header-anchor">#</a> Generic Types</h2> <p>在前面的部分中，我们创建了可在多种类型上使用的通用标识函数。
在本节中，我们将探讨函数本身的类型以及如何创建通用接口。</p> <p>泛型函数的类型与非泛型函数的类型相似，首先列出类型参数，类似于函数声明：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>我们也可以为类型中的泛型类型参数使用不同的名称，只要类型变量的数量以及类型变量的使用方式如何即可。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> <span class="token constant">U</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">U</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>我们还可以将泛型类型写为对象文字类型的调用签名：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">}</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>这导致我们编写第一个通用接口。
让我们从前面的示例中获取对象文字并将其移至接口：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">GenericIdentityFn</span> <span class="token punctuation">{</span>
    <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token operator">:</span> GenericIdentityFn <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>在类似的示例中，我们可能希望将通用参数移动为整个接口的参数。
这可以让我们看到我们通用的类型（例如，“ <code>Dictionary &lt;string&gt;</code>”而不是“ Dictionary”）。
这使类型参数对接口的所有其他成员可见。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">GenericIdentityFn</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> identity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myIdentity<span class="token operator">:</span> GenericIdentityFn<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> identity<span class="token punctuation">;</span>
</code></pre></div><p>有点不同。
现在，我们不再描述泛型函数，而是拥有一个非泛型函数签名，该签名是泛型类型的一部分。
现在，当我们使用GenericIdentityFn时，我们还需要指定相应的类型参数（此处为number），以有效地锁定底层调用签名所使用的类型。
了解何时将类型参数直接放在调用签名上以及何时将其放在接口本身上将有助于描述类型的哪些方面是通用的。</p> <p>除了通用接口，我们还可以创建通用类。
注意，不可能创建通用枚举和名称空间。</p> <h2 id="generic-classes"><a href="#generic-classes" class="header-anchor">#</a> Generic Classes</h2> <p>通用类具有与通用接口相似的形状。
泛型类在类名称后的尖括号（&lt;&lt;&gt;`）中具有泛型类型参数列表。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">GenericNumber</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    zeroValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token function-variable function">add</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myGenericNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericNumber</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myGenericNumber<span class="token punctuation">.</span>zeroValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
myGenericNumber<span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这实际上是对GenericNumber类的直接使用，但是您可能已经注意到，没有什么限制它只能使用number类型。
我们本来可以使用字符串或什至更复杂的对象。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> stringNumeric <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericNumber</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stringNumeric<span class="token punctuation">.</span>zeroValue <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
stringNumeric<span class="token punctuation">.</span><span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stringNumeric<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stringNumeric<span class="token punctuation">.</span>zeroValue<span class="token punctuation">,</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>与接口一样，将type参数放在类本身上也可以确保类的所有属性都使用相同的类型。</p> <p>正如我们在[关于类的部分]（./ Classes.md）中所述，类的类型有两个方面：静态方面和实例方面。
泛型类仅在其实例方面是泛型，而在其静态方面是泛型，因此在使用类时，静态成员不能使用该类的type参数。</p> <h2 id="generic-constraints"><a href="#generic-constraints" class="header-anchor">#</a> Generic Constraints</h2> <p>如果您从先前的示例中还记得，您有时可能想编写一个对一组类型起作用的通用函数，在此您对这些类型的集合将具有的功能有所了解。
在我们的loggingIdentity示例中，我们希望能够访问arg的.length属性，但是编译器无法证明每种类型都具有.length属性，因此它警告我们可以。做这个假设。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error: T doesn't have .length</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与其使用任何和所有类型，我们都希望限制此函数以使用也具有<code>.length</code>属性的任何和所有类型。
只要该类型具有此成员，我们就可以允许它，但是至少需要具有该成员。
为此，我们必须列出我们的要求作为对T的限制。</p> <p>为此，我们将创建一个描述约束的接口。
在这里，我们将创建一个具有单个<code>.length</code>属性的接口，然后使用该接口和<code>extends</code>关键字来表示我们的约束：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Lengthwise</span> <span class="token punctuation">{</span>
    length<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> loggingIdentity<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Lengthwise</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Now we know it has a .length property, so no more error</span>
    <span class="token keyword">return</span> arg<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于通用函数现在受到约束，因此它将不再适用于所有类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">loggingIdentity</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Error, number doesn't have a .length property</span>
</code></pre></div><p>相反，我们需要传递其类型具有所有必需属性的值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">loggingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">{</span>length<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="using-type-parameters-in-generic-constraints"><a href="#using-type-parameters-in-generic-constraints" class="header-anchor">#</a> Using Type Parameters in Generic Constraints</h2> <p>您可以声明受另一个类型参数约束的类型参数。
例如，在这里我们想从给定名称的对象获取属性。
我们想要确保我们不会意外地获取<code>obj</code>上不存在的属性，因此我们将在这两种类型之间放置一个约束：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> getProperty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> d<span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">getProperty</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
<span class="token function">getProperty</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token string">&quot;m&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span>
</code></pre></div><h2 id="using-class-types-in-generics"><a href="#using-class-types-in-generics" class="header-anchor">#</a> Using Class Types in Generics</h2> <p>使用泛型在TypeScript中创建工厂时，有必要通过其构造函数来引用类类型。例如，</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> create<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>c<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个更高级的示例使用prototype属性来推断和约束构造函数和类类型的实例端之间的关系。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">BeeKeeper</span> <span class="token punctuation">{</span>
    hasMask<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ZooKeeper</span> <span class="token punctuation">{</span>
    nametag<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    numLegs<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Bee</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    keeper<span class="token operator">:</span> BeeKeeper<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Lion</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    keeper<span class="token operator">:</span> ZooKeeper<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> createInstance<span class="token operator">&lt;</span><span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>c<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">createInstance</span><span class="token punctuation">(</span>Lion<span class="token punctuation">)</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span>nametag<span class="token punctuation">;</span>  <span class="token comment">// typechecks!</span>
<span class="token function">createInstance</span><span class="token punctuation">(</span>Bee<span class="token punctuation">)</span><span class="token punctuation">.</span>keeper<span class="token punctuation">.</span>hasMask<span class="token punctuation">;</span>   <span class="token comment">// typechecks!</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/7/2020, 3:48:55 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ts-translate/handbook/05-Function.html" class="prev">
        五、函数
      </a></span> <span class="next"><a href="/ts-translate/handbook/07-Enums.html">
        七、枚举
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ts-translate/assets/js/app.141fbb0f.js" defer></script><script src="/ts-translate/assets/js/2.a069a211.js" defer></script><script src="/ts-translate/assets/js/23.9732edd0.js" defer></script>
  </body>
</html>
