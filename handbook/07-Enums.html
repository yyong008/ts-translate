<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>七、枚举 | TypeScript手册</title>
    <meta name="description" content="TypeScript 学习手册">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/ts-translate/assets/css/0.styles.0a5bcfed.css" as="style"><link rel="preload" href="/ts-translate/assets/js/app.141fbb0f.js" as="script"><link rel="preload" href="/ts-translate/assets/js/2.a069a211.js" as="script"><link rel="preload" href="/ts-translate/assets/js/24.0ce34daf.js" as="script"><link rel="prefetch" href="/ts-translate/assets/js/10.06950121.js"><link rel="prefetch" href="/ts-translate/assets/js/11.6381239b.js"><link rel="prefetch" href="/ts-translate/assets/js/12.8176b810.js"><link rel="prefetch" href="/ts-translate/assets/js/13.0a03fbf3.js"><link rel="prefetch" href="/ts-translate/assets/js/14.3482aea1.js"><link rel="prefetch" href="/ts-translate/assets/js/15.7831b050.js"><link rel="prefetch" href="/ts-translate/assets/js/16.2e5641fb.js"><link rel="prefetch" href="/ts-translate/assets/js/17.caa1f0c3.js"><link rel="prefetch" href="/ts-translate/assets/js/18.33f52e19.js"><link rel="prefetch" href="/ts-translate/assets/js/19.8756dd76.js"><link rel="prefetch" href="/ts-translate/assets/js/20.cfed5059.js"><link rel="prefetch" href="/ts-translate/assets/js/21.090f26df.js"><link rel="prefetch" href="/ts-translate/assets/js/22.ff9d5ff1.js"><link rel="prefetch" href="/ts-translate/assets/js/23.9732edd0.js"><link rel="prefetch" href="/ts-translate/assets/js/25.240c5ec5.js"><link rel="prefetch" href="/ts-translate/assets/js/26.ece5b4f8.js"><link rel="prefetch" href="/ts-translate/assets/js/27.5cea32b1.js"><link rel="prefetch" href="/ts-translate/assets/js/28.4984b1b2.js"><link rel="prefetch" href="/ts-translate/assets/js/29.6cbf69a3.js"><link rel="prefetch" href="/ts-translate/assets/js/3.572305aa.js"><link rel="prefetch" href="/ts-translate/assets/js/30.21d3e389.js"><link rel="prefetch" href="/ts-translate/assets/js/31.e611e503.js"><link rel="prefetch" href="/ts-translate/assets/js/32.5d9d0c75.js"><link rel="prefetch" href="/ts-translate/assets/js/33.2cb939dd.js"><link rel="prefetch" href="/ts-translate/assets/js/34.f373a061.js"><link rel="prefetch" href="/ts-translate/assets/js/35.9d601f8b.js"><link rel="prefetch" href="/ts-translate/assets/js/36.45e2645f.js"><link rel="prefetch" href="/ts-translate/assets/js/37.ec9011fa.js"><link rel="prefetch" href="/ts-translate/assets/js/38.ecaf875b.js"><link rel="prefetch" href="/ts-translate/assets/js/39.79652b75.js"><link rel="prefetch" href="/ts-translate/assets/js/4.202d41bd.js"><link rel="prefetch" href="/ts-translate/assets/js/40.dfeb8b60.js"><link rel="prefetch" href="/ts-translate/assets/js/41.19371e04.js"><link rel="prefetch" href="/ts-translate/assets/js/42.12a43247.js"><link rel="prefetch" href="/ts-translate/assets/js/43.08babc31.js"><link rel="prefetch" href="/ts-translate/assets/js/5.7ad19b7d.js"><link rel="prefetch" href="/ts-translate/assets/js/6.f507dfa3.js"><link rel="prefetch" href="/ts-translate/assets/js/7.61be865b.js"><link rel="prefetch" href="/ts-translate/assets/js/8.b7b7c55c.js"><link rel="prefetch" href="/ts-translate/assets/js/9.59f9442d.js">
    <link rel="stylesheet" href="/ts-translate/assets/css/0.styles.0a5bcfed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ts-translate/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript手册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/ts-translate/handbook/01-Basic.html" class="sidebar-link">一、基本类型</a></li><li><a href="/ts-translate/handbook/02-VariableDecorations.html" class="sidebar-link">二、变量声明</a></li><li><a href="/ts-translate/handbook/03-Interface.html" class="sidebar-link">三、Interface 接口</a></li><li><a href="/ts-translate/handbook/04-Class.html" class="sidebar-link">四、类</a></li><li><a href="/ts-translate/handbook/05-Function.html" class="sidebar-link">五、函数</a></li><li><a href="/ts-translate/handbook/06-Generics.html" class="sidebar-link">六、泛型</a></li><li><a href="/ts-translate/handbook/07-Enums.html" class="active sidebar-link">七、枚举</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#numeric-enums" class="sidebar-link">Numeric enums</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#string-enums" class="sidebar-link">String enums</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#heterogeneous-enums" class="sidebar-link">Heterogeneous enums</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#computed-and-constant-members" class="sidebar-link">Computed and constant members</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#union-enums-and-enum-member-types" class="sidebar-link">Union enums and enum member types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#enums-at-runtime" class="sidebar-link">Enums at runtime</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#enums-at-compile-time" class="sidebar-link">Enums at compile time</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/07-Enums.html#ambient-enums" class="sidebar-link">Ambient enums</a></li></ul></li><li><a href="/ts-translate/handbook/08-TypeInference.html" class="sidebar-link">八、类型引用</a></li><li><a href="/ts-translate/handbook/09-TypeCompatibility.html" class="sidebar-link">九、兼容性</a></li><li><a href="/ts-translate/handbook/10-AdvanceTypes.html" class="sidebar-link">十、增强类型</a></li><li><a href="/ts-translate/handbook/11-Symbols.html" class="sidebar-link">十一、Symbol</a></li><li><a href="/ts-translate/handbook/12-IteratorAndGenerators.html" class="sidebar-link">十二、可迭代性 Iterables</a></li><li><a href="/ts-translate/handbook/13-Modules.html" class="sidebar-link">十三、模块</a></li><li><a href="/ts-translate/handbook/14-Namespaces.html" class="sidebar-link">十四、命名空间</a></li><li><a href="/ts-translate/handbook/15-NameSpacesModules.html" class="sidebar-link">十五、命名空间与模块</a></li><li><a href="/ts-translate/handbook/16-ModulesResolution.html" class="sidebar-link">十六、模块解析</a></li><li><a href="/ts-translate/handbook/17-DelarationMerging.html" class="sidebar-link">十七、声明合并</a></li><li><a href="/ts-translate/handbook/18-JSX.html" class="sidebar-link">十八、JSX</a></li><li><a href="/ts-translate/handbook/19-Decorators.html" class="sidebar-link">十九、修饰器</a></li><li><a href="/ts-translate/handbook/20-Mixins.html" class="sidebar-link">二十、混入</a></li><li><a href="/ts-translate/handbook/21-TripleSlashDirectives.html" class="sidebar-link">二十一、三斜线指令</a></li><li><a href="/ts-translate/handbook/22-JSDocSupportedTypes.html" class="sidebar-link">二十二、类型检查JavaScript文件</a></li><li><a href="/ts-translate/handbook/23-UtilityTypes.html" class="sidebar-link">二十三、联合类型</a></li><li><a href="/ts-translate/handbook/24-TypescriptIgnore.html" class="sidebar-link">二十四、TypeScript 类型忽略</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="七、枚举"><a href="#七、枚举" class="header-anchor">#</a> 七、枚举</h1> <p>枚举允许我们定义一组命名常量。
使用枚举可以更轻松地记录意图或创建一组不同的案例。
TypeScript提供数字和基于字符串的枚举。</p> <h2 id="numeric-enums"><a href="#numeric-enums" class="header-anchor">#</a> Numeric enums</h2> <p>我们首先从数字枚举开始，如果您来自其他语言，可能会更熟悉。
可以使用关键字enum定义一个枚举。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面是一个数字枚举，其中“ Up”被初始化为“ 1”。
从那时起，以下所有成员都会自动增加。
换句话说，Direction.Up的值为1，Down的值为2，Left的值为3，Right的值为4。</p> <p>如果需要，我们可以完全不使用初始化程序：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up<span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，“上”将具有值“ 0”，“下”将具有值“ 1”，依此类推。
这种自动递增的行为在以下情况下很有用：我们可能不在乎成员值本身，但在乎每个值都与同一个枚举中的其他值不同时。</p> <p>使用枚举很简单：只需从枚举本身访问任何成员作为属性，然后使用枚举的名称声明类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> Response <span class="token punctuation">{</span>
    No <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    Yes <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">respond</span><span class="token punctuation">(</span><span class="token parameter">recipient<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> message<span class="token operator">:</span> Response</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token function">respond</span><span class="token punctuation">(</span><span class="token string">&quot;Princess Caroline&quot;</span><span class="token punctuation">,</span> Response<span class="token punctuation">.</span>Yes<span class="token punctuation">)</span>
</code></pre></div><p>可以将数字枚举混合在[计算成员和常数成员（请参见下文）]（＃计算和常数成员）中。
简而言之，没有初始化程序的枚举要么需要首先使用，要么必须在用数字常量或其他常量枚举成员初始化的数字枚举之后出现。
换句话说，以下内容是不允许的：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token function">getSomeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token comment">// Error! Enum member must have initializer.</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="string-enums"><a href="#string-enums" class="header-anchor">#</a> String enums</h2> <p>字符串枚举是一个类似的概念，但具有一些细微的[运行时差异]（＃enums-at-runtime），如下所述。
在字符串枚举中，每个成员都必须使用字符串文字或另一个字符串枚举成员进行常量初始化。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> Direction <span class="token punctuation">{</span>
    Up <span class="token operator">=</span> <span class="token string">&quot;UP&quot;</span><span class="token punctuation">,</span>
    Down <span class="token operator">=</span> <span class="token string">&quot;DOWN&quot;</span><span class="token punctuation">,</span>
    Left <span class="token operator">=</span> <span class="token string">&quot;LEFT&quot;</span><span class="token punctuation">,</span>
    Right <span class="token operator">=</span> <span class="token string">&quot;RIGHT&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虽然字符串枚举没有自动递增的行为，但字符串枚举的好处是可以很好地“序列化”。
换句话说，如果您正在调试并且必须读取数字枚举的运行时值，则该值通常是不透明的-它本身无法传达任何有用的含义（尽管[反向映射]（＃enums-at-runtime ）通常可以提供帮助），字符串枚举可让您在代码运行时提供有意义且可读的值，而与枚举成员本身的名称无关。</p> <h2 id="heterogeneous-enums"><a href="#heterogeneous-enums" class="header-anchor">#</a> Heterogeneous enums</h2> <p>从技术上讲，枚举可以与字符串和数字成员混合，但尚不清楚为什么要这样做：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> BooleanLikeHeterogeneousEnum <span class="token punctuation">{</span>
    No <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    Yes <span class="token operator">=</span> <span class="token string">&quot;YES&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除非您真的想以一种聪明的方式利用JavaScript的运行时行为，否则建议您不要这样做。</p> <h2 id="computed-and-constant-members"><a href="#computed-and-constant-members" class="header-anchor">#</a> Computed and constant members</h2> <p>每个枚举成员都有一个与之关联的值，该值可以是* constant <em>或</em> computed *。
枚举成员被视为常量，如果：</p> <p>*它是枚举中的第一个成员，并且没有初始化程序，在这种情况下，其分配值为'0'：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// E.X is constant:</span>
<span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span> <span class="token constant">X</span> <span class="token punctuation">}</span>
</code></pre></div><ul><li><p>它没有初始化程序，并且前面的枚举成员是<em>数字</em>常量。
  在这种情况下，当前枚举成员的值将是前一个枚举成员的值加1。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// All enum members in 'E1' and 'E2' are constant.</span>

<span class="token keyword">enum</span> <span class="token constant">E1</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">Z</span> <span class="token punctuation">}</span>

<span class="token keyword">enum</span> <span class="token constant">E2</span> <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>枚举成员使用常量枚举表达式初始化。
  常量枚举表达式是TypeScript表达式的子集，可以在编译时对其进行完全求值。
  表达式是以下常量枚举表达式：</p></li></ul> <p>1.文字枚举表达式（基本上是字符串文字或数字文字）
    2.引用先前定义的常量枚举成员（可以源自其他枚举）
    3.带括号的常量枚举表达式
    4.“ +”，“-”，“〜”一元运算符之一应用于常量枚举表达式
    5.<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>％</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&gt;&gt;&gt;</code>，<code>＆</code>，<code>|</code>，<code>^</code>二进制以常量枚举表达式作为操作数的运算符</p> <p>将常量枚举表达式评估为NaN或Infinity是编译时错误。</p> <p>在所有其他情况下，枚举成员被视为已计算。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> FileAccess <span class="token punctuation">{</span>
    <span class="token comment">// constant members</span>
    None<span class="token punctuation">,</span>
    Read    <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span>
    Write   <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">,</span>
    ReadWrite  <span class="token operator">=</span> Read <span class="token operator">|</span> Write<span class="token punctuation">,</span>
    <span class="token comment">// computed member</span>
    <span class="token constant">G</span> <span class="token operator">=</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">.</span>length
<span class="token punctuation">}</span>
</code></pre></div><h2 id="union-enums-and-enum-member-types"><a href="#union-enums-and-enum-member-types" class="header-anchor">#</a> Union enums and enum member types</h2> <p>有一个未计算的常量枚举成员的特殊子集：文字枚举成员。
文字枚举成员是没有初始化值或具有初始化为的值的常量枚举成员</p> <p>*任何字符串文字（例如<code>“ foo”</code>，<code>“ bar</code>，<code>” baz“</code>）
*任何数字文字（例如，“ 1”，“ 100”）
*适用于任何数字文字的一元减号（例如<code>-1</code>，<code>-100</code>）</p> <p>当枚举中的所有成员都具有文字枚举值时，就会使用一些特殊的语义。</p> <p>首先是枚举成员也将成为类型！
例如，我们可以说某些成员可以* only *具有枚举成员的值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> ShapeKind <span class="token punctuation">{</span>
    Circle<span class="token punctuation">,</span>
    Square<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Circle<span class="token punctuation">;</span>
    radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Square<span class="token punctuation">;</span>
    sideLength<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> c<span class="token operator">:</span> Circle <span class="token operator">=</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> ShapeKind<span class="token punctuation">.</span>Square<span class="token punctuation">,</span> <span class="token comment">// Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.</span>
    radius<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另一个变化是枚举类型本身有效地成为每个枚举成员的“联合”。
尽管我们还没有讨论[union types]（./ Advanced％20Types.md＃union-types），但是您需要知道的是，对于联合枚举，类型系统能够利用它知道以下事实：枚举本身中存在的一组确切值。
因此，TypeScript可以捕获愚蠢的错误，在这些错误中我们可能会错误地比较值。
例如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    Foo<span class="token punctuation">,</span>
    Bar<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token constant">E</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Foo <span class="token operator">||</span> x <span class="token operator">!==</span> <span class="token constant">E</span><span class="token punctuation">.</span>Bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//             ~~~~~~~~~~~</span>
        <span class="token comment">// Error! This condition will always return 'true' since the types 'E.Foo' and 'E.Bar' have no overlap.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在该示例中，我们首先检查x是否为* E.Foo。
如果检查成功，则我们的<code>||</code>将短路，并且'if'的主体将运行。
但是，如果检查不成功，则x只能*为E.Foo，因此查看是否等于E.Bar没什么意义。</p> <h2 id="enums-at-runtime"><a href="#enums-at-runtime" class="header-anchor">#</a> Enums at runtime</h2> <p>枚举是在运行时存在的真实对象。
例如下面的枚举</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> <span class="token constant">E</span> <span class="token punctuation">{</span>
    <span class="token constant">X</span><span class="token punctuation">,</span> <span class="token constant">Y</span><span class="token punctuation">,</span> <span class="token constant">Z</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际上可以传递给函数</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token constant">X</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token constant">X</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Works, since 'E' has a property named 'X' which is a number.</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token constant">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="enums-at-compile-time"><a href="#enums-at-compile-time" class="header-anchor">#</a> Enums at compile time</h2> <p>尽管枚举是在运行时存在的真实对象，但关键字keyof的工作原理与您对典型对象的预期不同。取而代之的是，使用<code>keyof typeof</code>来获得一个Type，该Type将所有Enum键表示为字符串。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> LogLevel <span class="token punctuation">{</span>
    <span class="token constant">ERROR</span><span class="token punctuation">,</span> <span class="token constant">WARN</span><span class="token punctuation">,</span> <span class="token constant">INFO</span><span class="token punctuation">,</span> <span class="token constant">DEBUG</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * This is equivalent to:
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */</span>
<span class="token keyword">type</span> LogLevelStrings <span class="token operator">=</span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> LogLevel<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">printImportant</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token operator">:</span> LogLevelStrings<span class="token punctuation">,</span> message<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> num <span class="token operator">=</span> LogLevel<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;=</span> LogLevel<span class="token punctuation">.</span><span class="token constant">WARN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Log level key is: '</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Log level value is: '</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Log level message is: '</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">printImportant</span><span class="token punctuation">(</span><span class="token string">'ERROR'</span><span class="token punctuation">,</span> <span class="token string">'This is a message'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="reverse-mappings"><a href="#reverse-mappings" class="header-anchor">#</a> Reverse mappings</h3> <p>除了创建具有成员属性名称的对象外，数字枚举成员还获得从枚举值到枚举名称的“反向映射”。
例如，在此示例中：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> Enum<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> nameOfA <span class="token operator">=</span> Enum<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;A&quot;</span>
</code></pre></div><p>TypeScript可能会将其编译为以下JavaScript：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Enum<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Enum<span class="token punctuation">[</span>Enum<span class="token punctuation">[</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Enum <span class="token operator">||</span> <span class="token punctuation">(</span>Enum <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> Enum<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> nameOfA <span class="token operator">=</span> Enum<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// &quot;A&quot;</span>
</code></pre></div><p>在此生成的代码中，一个枚举被编译到一个对象中，该对象同时存储正向（“ name”-&gt;“ value”）和反向（“ value”-&gt;“ name”）映射。
对其他枚举成员的引用始终作为属性访问发出，并且从不内联。</p> <p>请记住，字符串枚举成员<em>根本不会</em>得到反向映射。</p> <h3 id="const-enums"><a href="#const-enums" class="header-anchor">#</a> <code>const</code> enums</h3> <p>在大多数情况下，枚举是一个完美有效的解决方案。
但是有时要求会更严格。
为了避免在访问枚举值时支付额外的生成代码和额外的间接调用的开销，可以使用<code>const</code>枚举。
const枚举是在我们的枚举上使用<code>const</code>修饰符定义的：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token constant">B</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">*</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>const枚举只能使用常量枚举表达式，与常规枚举不同，它们在编译期间会被完全删除。
const枚举成员在使用站点内联。
这是可能的，因为const枚举不能具有计算成员。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token keyword">enum</span> Directions <span class="token punctuation">{</span>
    Up<span class="token punctuation">,</span>
    Down<span class="token punctuation">,</span>
    Left<span class="token punctuation">,</span>
    Right
<span class="token punctuation">}</span>

<span class="token keyword">let</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span>Directions<span class="token punctuation">.</span>Up<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Down<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> Directions<span class="token punctuation">.</span>Right<span class="token punctuation">]</span>
</code></pre></div><p>在生成的代码将成为</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> directions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token comment">/* Up */</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token comment">/* Down */</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">/* Left */</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token comment">/* Right */</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="ambient-enums"><a href="#ambient-enums" class="header-anchor">#</a> Ambient enums</h2> <p>环境枚举用于描述已经存在的枚举类型的形状。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">enum</span> Enum <span class="token punctuation">{</span>
    <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token constant">B</span><span class="token punctuation">,</span>
    <span class="token constant">C</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>环境枚举和非环境枚举之间的一个重要区别是，在常规枚举中，如果没有其初始值设定项的成员被视为常量，则该成员将被视为常量。
相反，没有初始化的环境（和非const）枚举成员始终被视为已计算。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/7/2020, 3:48:55 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ts-translate/handbook/06-Generics.html" class="prev">
        六、泛型
      </a></span> <span class="next"><a href="/ts-translate/handbook/08-TypeInference.html">
        八、类型引用
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ts-translate/assets/js/app.141fbb0f.js" defer></script><script src="/ts-translate/assets/js/2.a069a211.js" defer></script><script src="/ts-translate/assets/js/24.0ce34daf.js" defer></script>
  </body>
</html>
