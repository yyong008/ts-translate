<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>二、变量声明 | TypeScript手册</title>
    <meta name="description" content="TypeScript 学习手册">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/ts-translate/assets/css/0.styles.0a5bcfed.css" as="style"><link rel="preload" href="/ts-translate/assets/js/app.141fbb0f.js" as="script"><link rel="preload" href="/ts-translate/assets/js/2.a069a211.js" as="script"><link rel="preload" href="/ts-translate/assets/js/19.8756dd76.js" as="script"><link rel="prefetch" href="/ts-translate/assets/js/10.06950121.js"><link rel="prefetch" href="/ts-translate/assets/js/11.6381239b.js"><link rel="prefetch" href="/ts-translate/assets/js/12.8176b810.js"><link rel="prefetch" href="/ts-translate/assets/js/13.0a03fbf3.js"><link rel="prefetch" href="/ts-translate/assets/js/14.3482aea1.js"><link rel="prefetch" href="/ts-translate/assets/js/15.7831b050.js"><link rel="prefetch" href="/ts-translate/assets/js/16.2e5641fb.js"><link rel="prefetch" href="/ts-translate/assets/js/17.caa1f0c3.js"><link rel="prefetch" href="/ts-translate/assets/js/18.33f52e19.js"><link rel="prefetch" href="/ts-translate/assets/js/20.cfed5059.js"><link rel="prefetch" href="/ts-translate/assets/js/21.090f26df.js"><link rel="prefetch" href="/ts-translate/assets/js/22.ff9d5ff1.js"><link rel="prefetch" href="/ts-translate/assets/js/23.9732edd0.js"><link rel="prefetch" href="/ts-translate/assets/js/24.0ce34daf.js"><link rel="prefetch" href="/ts-translate/assets/js/25.240c5ec5.js"><link rel="prefetch" href="/ts-translate/assets/js/26.ece5b4f8.js"><link rel="prefetch" href="/ts-translate/assets/js/27.5cea32b1.js"><link rel="prefetch" href="/ts-translate/assets/js/28.4984b1b2.js"><link rel="prefetch" href="/ts-translate/assets/js/29.6cbf69a3.js"><link rel="prefetch" href="/ts-translate/assets/js/3.572305aa.js"><link rel="prefetch" href="/ts-translate/assets/js/30.21d3e389.js"><link rel="prefetch" href="/ts-translate/assets/js/31.e611e503.js"><link rel="prefetch" href="/ts-translate/assets/js/32.5d9d0c75.js"><link rel="prefetch" href="/ts-translate/assets/js/33.2cb939dd.js"><link rel="prefetch" href="/ts-translate/assets/js/34.f373a061.js"><link rel="prefetch" href="/ts-translate/assets/js/35.9d601f8b.js"><link rel="prefetch" href="/ts-translate/assets/js/36.45e2645f.js"><link rel="prefetch" href="/ts-translate/assets/js/37.ec9011fa.js"><link rel="prefetch" href="/ts-translate/assets/js/38.ecaf875b.js"><link rel="prefetch" href="/ts-translate/assets/js/39.79652b75.js"><link rel="prefetch" href="/ts-translate/assets/js/4.202d41bd.js"><link rel="prefetch" href="/ts-translate/assets/js/40.dfeb8b60.js"><link rel="prefetch" href="/ts-translate/assets/js/41.19371e04.js"><link rel="prefetch" href="/ts-translate/assets/js/42.12a43247.js"><link rel="prefetch" href="/ts-translate/assets/js/43.08babc31.js"><link rel="prefetch" href="/ts-translate/assets/js/5.7ad19b7d.js"><link rel="prefetch" href="/ts-translate/assets/js/6.f507dfa3.js"><link rel="prefetch" href="/ts-translate/assets/js/7.61be865b.js"><link rel="prefetch" href="/ts-translate/assets/js/8.b7b7c55c.js"><link rel="prefetch" href="/ts-translate/assets/js/9.59f9442d.js">
    <link rel="stylesheet" href="/ts-translate/assets/css/0.styles.0a5bcfed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ts-translate/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript手册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/ts-translate/handbook/01-Basic.html" class="sidebar-link">一、基本类型</a></li><li><a href="/ts-translate/handbook/02-VariableDecorations.html" class="active sidebar-link">二、变量声明</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#var-声明" class="sidebar-link">var 声明</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#let-声明" class="sidebar-link">let 声明</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#作用域块" class="sidebar-link">作用域块</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#重新定义和覆盖" class="sidebar-link">重新定义和覆盖</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#块级作用域变量的捕获" class="sidebar-link">块级作用域变量的捕获</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#const-声明" class="sidebar-link">const 声明</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#let-vs-const" class="sidebar-link">let vs const</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#destructuring-解构" class="sidebar-link">Destructuring 解构</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#对象的结构" class="sidebar-link">对象的结构</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/02-VariableDecorations.html#函数声明" class="sidebar-link">函数声明</a></li></ul></li><li><a href="/ts-translate/handbook/03-Interface.html" class="sidebar-link">三、Interface 接口</a></li><li><a href="/ts-translate/handbook/04-Class.html" class="sidebar-link">四、类</a></li><li><a href="/ts-translate/handbook/05-Function.html" class="sidebar-link">五、函数</a></li><li><a href="/ts-translate/handbook/06-Generics.html" class="sidebar-link">六、泛型</a></li><li><a href="/ts-translate/handbook/07-Enums.html" class="sidebar-link">七、枚举</a></li><li><a href="/ts-translate/handbook/08-TypeInference.html" class="sidebar-link">八、类型引用</a></li><li><a href="/ts-translate/handbook/09-TypeCompatibility.html" class="sidebar-link">九、兼容性</a></li><li><a href="/ts-translate/handbook/10-AdvanceTypes.html" class="sidebar-link">十、增强类型</a></li><li><a href="/ts-translate/handbook/11-Symbols.html" class="sidebar-link">十一、Symbol</a></li><li><a href="/ts-translate/handbook/12-IteratorAndGenerators.html" class="sidebar-link">十二、可迭代性 Iterables</a></li><li><a href="/ts-translate/handbook/13-Modules.html" class="sidebar-link">十三、模块</a></li><li><a href="/ts-translate/handbook/14-Namespaces.html" class="sidebar-link">十四、命名空间</a></li><li><a href="/ts-translate/handbook/15-NameSpacesModules.html" class="sidebar-link">十五、命名空间与模块</a></li><li><a href="/ts-translate/handbook/16-ModulesResolution.html" class="sidebar-link">十六、模块解析</a></li><li><a href="/ts-translate/handbook/17-DelarationMerging.html" class="sidebar-link">十七、声明合并</a></li><li><a href="/ts-translate/handbook/18-JSX.html" class="sidebar-link">十八、JSX</a></li><li><a href="/ts-translate/handbook/19-Decorators.html" class="sidebar-link">十九、修饰器</a></li><li><a href="/ts-translate/handbook/20-Mixins.html" class="sidebar-link">二十、混入</a></li><li><a href="/ts-translate/handbook/21-TripleSlashDirectives.html" class="sidebar-link">二十一、三斜线指令</a></li><li><a href="/ts-translate/handbook/22-JSDocSupportedTypes.html" class="sidebar-link">二十二、类型检查JavaScript文件</a></li><li><a href="/ts-translate/handbook/23-UtilityTypes.html" class="sidebar-link">二十三、联合类型</a></li><li><a href="/ts-translate/handbook/24-TypescriptIgnore.html" class="sidebar-link">二十四、TypeScript 类型忽略</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="二、变量声明"><a href="#二、变量声明" class="header-anchor">#</a> 二、变量声明</h1> <p>在 JavaScript 中， <code>let</code> 和 <code>const</code> 是两个相对新的变量声明, <a href="/ts-translate/handbook/01-base.html##关于-let-的注释">正如前面提及的</a>，<code>let</code> 与 <code>var</code> 在某些地方是相似的，但是它能够避免一个用户在 JavaScript 中使用使用时存在的一些常见的问题。 <code>const</code> 是对 <code>let</code> 增强阻止一个变量的再分配。</p> <p>TypeScript 是 JavaScript 的超集，在 TypeScrip 中自然是支持 <code>let</code> 和 <code>const</code>。在这里我们将会详尽的说明这些新的声明和为什么它们比 <code>var</code>更好。</p> <p>如果你 JavaScript 的时候非常的随意，没有注意 <code>var</code>, 下面的这些可能会刷新你的认知。如果你对 JavaScript 的 var 已经得心应手，你可以跳过这一个章节。</p> <h2 id="var-声明"><a href="#var-声明" class="header-anchor">#</a> <code>var</code> 声明</h2> <p>在 JavaScript 中声明一个变量，一般都是使用 <code>var</code> 关键字。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
</code></pre></div><p>正如大家都能理解的， 这里声明了一个变量 <code>a</code> 值是 <code>10</code>。</p> <p>我们也可以在函数内部定义一个变量:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">'Hello, world'</span>

  <span class="token keyword">return</span> message
<span class="token punctuation">}</span>
</code></pre></div><p>我们也能在其他的函数里面访问相同的变量</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">return</span> b
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// return '11'</span>
</code></pre></div><p>在这个例子中， <code>g</code> 在 <code>f</code> 中声明捕获了变量 <code>a</code>。在任何 <code>g</code> 被调用的时候，<code>a</code> 都能被访问到。甚至 <code>g</code> 已经被访问一次了，但是依然能访问和修该 <code>a</code>。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>

  a <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  a <span class="token operator">=</span> <span class="token number">3</span>

  <span class="token keyword">return</span> b

  <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// returns '2'</span>
</code></pre></div><h3 id="作用域规则"><a href="#作用域规则" class="header-anchor">#</a> 作用域规则</h3> <p><code>var</code> 变量对于其他的语言来说有很多奇怪的规则。就好比下面这个例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">shouldInitialize<span class="token operator">:</span> <span class="token builtin">boolean</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldInitialize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> x
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// returns '10'</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// returns 'undefined'</span>
</code></pre></div><p>一些读者可能要反复的看这个例子。</p> <p>变量 <code>x</code> 被声明在 <code>if</code> 语句中， 然而我们能够在这块的外部也能访问到它。这是因为 <code>var</code> 声明是能够在任何包含在函数，模块，命名空间或者全局的作用域都能访问到。包含它的代码块是没任何的影响。稍后我们会对所有的这些进行讲解。</p> <p>这些作用域能够导致一些错误，一个致命错误就是同一个变量声明多次。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span><span class="token parameter">matrix<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> sum
<span class="token punctuation">}</span>
</code></pre></div><p>或许很容易的就找到了这里面的问题，内部的 for 循环将彻底重写变量 <code>i</code> 因为 <code>i</code> 引用了相同的作用域。</p> <p>有经验的开发者知道，这些代码在 Reviews 的时候很容的就漏掉了，引起无穷的麻烦。</p> <h3 id="捕获编译的地方"><a href="#捕获编译的地方" class="header-anchor">#</a> 捕获编译的地方</h3> <p>快速的猜一猜下面的代码输出的是什么？</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>说明一下， <code>setTimeout</code> 将在几千毫秒之后执行（直道其他的代码执行完毕）。</p> <p>准备？看这里：</p> <div class="language-text extra-class"><pre class="language-text"><code>10
10
10
10
10
10
10
10
10
10
</code></pre></div><p>很多的 JavaScript 的开发这已经熟悉了这些的行为，但是你如果感到惊讶，你确定不是一个人。很多人期待的输出下面这些：</p> <div class="language-text extra-class"><pre class="language-text"><code>0
1
2
3
4
5
6
7
8
9
</code></pre></div><p>还记得我们在前面提及到的捕获的变量吗？</p> <blockquote><p>我们传给 <code>setTimeout</code> 函数表达式的每一个参数都是引用了同一个 <code>i</code> 从一个相同的作用域里面。</p></blockquote> <p>让我们来思考一下。 <code>setTimeout</code> 将运行在若干毫秒之后，<em>但是仅仅</em> <code>for</code> 循环停止之后执行，<code>for</code> 循环停止循环，这个时候 <code>i</code> 的值是 <code>10</code>。因此每次函数被调用都会打印出 <code>10</code>;</p> <p>一个通用的方法是使用立即执行函数 IEEF，一个立即函数执行表达式在每次迭代中去捕获 <code>i</code>；</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// capture the current state of 'i'</span>
  <span class="token comment">// by invoking a function with its current value</span>
  <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种奇怪的形式我们已经司空见惯了。 参数 i 会覆盖 for 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 for 循环体里的代码。</p> <h2 id="let-声明"><a href="#let-声明" class="header-anchor">#</a> <code>let</code> 声明</h2> <p>现在你能够意识到 <code>var</code> 存在的问题了， 这就是为什么要引入 <code>let</code> 的原因。除了关键字的使用之外，其它方面是一样的！</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">'Hello!'</span>
</code></pre></div><p>关键的不是语法，而是语义，我们现在深入的探讨这个问题</p> <h2 id="作用域块"><a href="#作用域块" class="header-anchor">#</a> 作用域块</h2> <p>当我们使用<code>let</code>声明一个变量，它使用的是<code>词法作用域</code>或者<code>块级作用域</code>。不向使用 <code>var</code> 声明一个变量，在包含的函数外面能够使用变量，块级作用域变量在包含它的块和 for 循环之外是不能使用的</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">input<span class="token operator">:</span> <span class="token builtin">boolean</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Still okay to reference 'a'</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">return</span> b
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> b <span class="token comment">// // Error: 'b' doesn't exist here</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，我们定义了两个变量 <code>a</code> 和 <code>b</code>. <code>a</code> 被限制在 <code>f</code> 的作用域里面，而 <code>b</code>  被限制在 if 语句所在的作用域里面。</p> <p>变量声明在 <code>catch</code> 里面，也会有相同的作用域规则。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
 <span class="token keyword">throw</span> <span class="token string">&quot;oh no!&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Oh well.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token comment">// Error: 'e' doesn't exist here</span>
</code></pre></div><p>块级作用域的另一个特性就是，在正确的声明之前是能够正确的声明的。虽然这些变量<code>存在</code>于作用域中，但是声明它之前都属于<strong>暂时性死区</strong>。 <code>let</code> 声明不能再声明它之前访问，但是幸运的是 TypeScript 能够告诉你这些。</p> <div class="language-ts extra-class"><pre class="language-ts"><code>a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// illegal to use 'a' before it's declared;</span>
<span class="token keyword">let</span> a<span class="token punctuation">;</span>
</code></pre></div><p>需要注意的是, 我们任然能够在声明一个变量之前<strong>捕获</strong>它。在没有声明之前调用它是不合法的。如果构建目标是 E2015 现代的运行时或抛出一个错误。现在 TypeScript 是允许也不会对跑出一个错误。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 我们能够捕获一个 a 变量</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a 被声明之前调用 foo 是非法的！运行时会报错</span>

<span class="token keyword">let</span> a<span class="token punctuation">;</span>
</code></pre></div><p>关于暂时性死区我们更多的信息我们可以查看这里<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="noopener noreferrer">Mozilla Developer Network<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h2 id="重新定义和覆盖"><a href="#重新定义和覆盖" class="header-anchor">#</a> 重新定义和覆盖</h2> <p>在 <code>var</code> 声明中，我们提及到了，<code>var</code> 声明和次数是没有关系的，你只会得到一个。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的例子中，所有的的 <code>x</code> 声明都引用了同一个 <code>x</code> 声明。这是完全有效的。这些通常是 bugs 的来源。幸运的是，<code>let</code> 是没有这么的宽容。（计算机越严谨，问题也相对越少）</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// error: can't re-declare 'x' in the same scope</span>
</code></pre></div><p>并不是要求两个均是块级作用域的声明，TypeScript才会给出一个错误的警告。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// error: interferes with parameter declaration</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// error: can't have both declarations of 'x'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">condition<span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns '0'</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// returns '100'</span>
</code></pre></div><p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span><span class="token parameter">matrix<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个版本的循环能得到正确的结果，因为<code>内层循环</code>的i可以<code>屏蔽掉外层循环</code>的i。</p> <p>通常来讲应该<code>避免使用屏蔽</code>，因为我们需要写出<code>清晰的代码</code>。 同时也有些场景适合利用它，你需要好好打算一下。</p> <h2 id="块级作用域变量的捕获"><a href="#块级作用域变量的捕获" class="header-anchor">#</a> 块级作用域变量的捕获</h2> <p>当我们第一次涉及到捕获，我们简略的探究了变量获取之后如何运行的。直观的讲，每次进入作用创建一个变量的环境。就算内部的代码执行完毕，这个执行环境与其捕获的变量依旧存在！</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">theCityThatAlwaysSleeps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> getCity<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> city <span class="token operator">=</span> <span class="token string">&quot;Seattle&quot;</span><span class="token punctuation">;</span>
        <span class="token function-variable function">getCity</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为我们已经在 City 的环境里获取了 City, 所及就算 if 语句执行结束之后我们依然可以使用他们。</p> <p>回想一下我们 setTimeout 的例子，需要使用立即执行函数来每次获取 for 循环里面的迭代状态。实际上，我们做的是为每一个变量创建一个新的变量环境。这样做是很痛苦的，但是我们必须这样做，庆幸的是，我们不必在 TypeScript 里面这样做了。</p> <p><code>let</code> 声明在一个循环里面的时候，会有不同的行为。不仅仅是创建了一个新的环境变量，而且会针对每次迭代创建一个新的作用域。这些是我们在使用立即执行表达式里面所做的事情，现在只需要使用 <code>let</code> 就可以了。所以我们在使用 <code>setTimeout</code>的时候，只需要使用 <code>let</code> 就行了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">*</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="const-声明"><a href="#const-声明" class="header-anchor">#</a> <code>const</code> 声明</h2> <p><code>const</code> 是另一种声明的方式。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
</code></pre></div><p>它和 <code>let</code> 很相似，但是就如同它的名字一样。他们被赋值之后是不能改变的。它与 <code>let</code> 有相同的作用域，但是我们不能够对齐重新分配值。</p> <p>这样也很好理解：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;Aurora&quot;</span><span class="token punctuation">,</span>
    numLives<span class="token operator">:</span> numLivesForCat<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// Error</span>
kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;Danielle&quot;</span><span class="token punctuation">,</span>
    numLives<span class="token operator">:</span> numLivesForCat
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// all &quot;okay&quot;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Rory&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Kitty&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Cat&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>numLives<span class="token operator">--</span><span class="token punctuation">;</span>
</code></pre></div><p>除非你使用特殊的方式去规避它。其实在 const 声明的变量内部是可修改的。可以庆幸的是，在 TyeScript 中，可以将对象的成员设置成只读属性，<a href="/ts-translate/handbook/03-interface.html">接口</a>一章有详细说明。</p> <h2 id="let-vs-const"><a href="#let-vs-const" class="header-anchor">#</a> <code>let</code> vs <code>const</code></h2> <p>两个声明有相似的作用域方式，你会问到底要使用哪一个呢？与其它问题一样，视情况而定。</p> <p>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener noreferrer">最小特权原则<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所有你计划不去修改的变量都应该使用 <code>const</code> 。一个基本的原则就是，一个变量不需要被重写，其它使用这个变量的人也不能使用这个变量并写入，并且思考为什么要对这些变量进行重新分配。</p> <p>根据你的判断，跟团队协商一下，如果合适的化。</p> <h2 id="destructuring-解构"><a href="#destructuring-解构" class="header-anchor">#</a> Destructuring 解构</h2> <p>Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener noreferrer">the article on the Mozilla Developer Network<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>我们将给出一个简短的概述。</p> <h3 id="解构数组"><a href="#解构数组" class="header-anchor">#</a> 解构数组</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 2</span>
</code></pre></div><p>创建了两个变量名 <code>first</code> 和 <code>second</code>, 相当于使用了索引，但是更好用了：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>first <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
second <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>解构可以更好的作用域已经声明的变量：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// swap variables</span>
<span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> first<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>作用于函数参数：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>
</code></pre></div><p>你可以在数组里使用...语法创建剩余变量：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs [ 2, 3, 4 ]</span>
</code></pre></div><p>当然是 JavaScript， 你可忽略尾部的一些元素：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
</code></pre></div><p>或其它元素：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> second<span class="token punctuation">,</span> <span class="token punctuation">,</span> fourth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="元组的解构"><a href="#元组的解构" class="header-anchor">#</a> 元组的解构</h3> <p>元组的解构和数组的结构很相似。解构的变量能够正确的获取变量的类型</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> tuple<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> tuple<span class="token punctuation">;</span> <span class="token comment">// a: number, b: string, c: boolean</span>
</code></pre></div><p>解构一个数组超出了范围，会抛出一个错误：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">]</span> <span class="token operator">=</span> tuple<span class="token punctuation">;</span> <span class="token comment">// Error, no element at index 3</span>
</code></pre></div><p>如果是一个数组，你可以使用 <code>...</code> 展开运算符，来得到一个短的元组。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>bc<span class="token punctuation">]</span> <span class="token operator">=</span> tuple<span class="token punctuation">;</span> <span class="token comment">// bc: [string, boolean]</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token operator">...</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> tuple<span class="token punctuation">;</span> <span class="token comment">// d: [], the empty tuple</span>
</code></pre></div><p>忽略尾部的元素，或者其他的元素</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> tuple<span class="token punctuation">;</span> <span class="token comment">// a: number</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> tuple<span class="token punctuation">;</span> <span class="token comment">// b: string</span>
</code></pre></div><h2 id="对象的结构"><a href="#对象的结构" class="header-anchor">#</a> 对象的结构</h2> <p>你也能使用对象的结构：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span>
    b<span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
    c<span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p> <p>就像数组解构，你可以用没有声明的赋值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">&quot;baz&quot;</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">101</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，我们需要用括号将它括起来，因为 Javascript 通常会将以 <code>{</code> 起始的语句解析为一个块。</p> <p>你可以在对象里使用...语法创建剩余变量：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>passthrough <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
<span class="token keyword">let</span> total <span class="token operator">=</span> passthrough<span class="token punctuation">.</span>b <span class="token operator">+</span> passthrough<span class="token punctuation">.</span>c<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre></div><h3 id="属性重命名"><a href="#属性重命名" class="header-anchor">#</a> 属性重命名</h3> <p>你也可以给一个不同的名字：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> newName1<span class="token punctuation">,</span> b<span class="token operator">:</span> newName2 <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>这里的语法开始变得混乱。 你可以将 a: newName1 读做 &quot;a 作为 newName1&quot;。 方向是从左到右，好像你写成了以下样子</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> newName1 <span class="token operator">=</span> o<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
<span class="token keyword">let</span> newName2 <span class="token operator">=</span> o<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
</code></pre></div><p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><h3 id="默认值"><a href="#默认值" class="header-anchor">#</a> 默认值</h3> <p>默认值可以让你在属性为 undefined 时使用缺省值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">keepWholeObject</span><span class="token punctuation">(</span><span class="token parameter">wholeObject<span class="token operator">:</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1001</span> <span class="token punctuation">}</span> <span class="token operator">=</span> wholeObject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p> <h2 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h2> <p>解构也能用于函数声明。 看以下简单的情况：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token constant">C</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p></blockquote> <p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">&quot;yes&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, default b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, default to { a: &quot;&quot; }, which then defaults b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, 'a' is required if you supply an argument</span>
</code></pre></div><p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p> <h3 id="展开"><a href="#展开" class="header-anchor">#</a> 展开</h3> <p>展开正好和结构相反。它允许你将一个数组展开为另一个数组。一个对象展开为另一个对象。</p> <p>例如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> second <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bothPlus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>second<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>这会令 <code>bothPlus</code> 的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second</code> 的一份浅拷贝。 它们不会被展开操作所改变。</p> <p>你还可以展开对象：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token operator">:</span> <span class="token string">&quot;spicy&quot;</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token string">&quot;$$&quot;</span><span class="token punctuation">,</span> ambiance<span class="token operator">:</span> <span class="token string">&quot;noisy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>defaults<span class="token punctuation">,</span> food<span class="token operator">:</span> <span class="token string">&quot;rich&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>search的</code> 值为 <code>{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }</code> 。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token operator">:</span> <span class="token string">&quot;spicy&quot;</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token string">&quot;$$&quot;</span><span class="token punctuation">,</span> ambiance<span class="token operator">:</span> <span class="token string">&quot;noisy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token operator">:</span> <span class="token string">&quot;rich&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span>defaults <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。</p> <p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  p <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>c <span class="token punctuation">}</span><span class="token punctuation">;</span>
clone<span class="token punctuation">.</span>p<span class="token punctuation">;</span> <span class="token comment">// ok</span>
clone<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>
</code></pre></div><p>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/7/2020, 3:48:55 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ts-translate/handbook/01-Basic.html" class="prev">
        一、基本类型
      </a></span> <span class="next"><a href="/ts-translate/handbook/03-Interface.html">
        三、Interface 接口
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ts-translate/assets/js/app.141fbb0f.js" defer></script><script src="/ts-translate/assets/js/2.a069a211.js" defer></script><script src="/ts-translate/assets/js/19.8756dd76.js" defer></script>
  </body>
</html>
