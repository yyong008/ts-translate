<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>十、增强类型 | TypeScript手册</title>
    <meta name="description" content="TypeScript 学习手册">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/ts-translate/assets/css/0.styles.0a5bcfed.css" as="style"><link rel="preload" href="/ts-translate/assets/js/app.141fbb0f.js" as="script"><link rel="preload" href="/ts-translate/assets/js/2.a069a211.js" as="script"><link rel="preload" href="/ts-translate/assets/js/27.5cea32b1.js" as="script"><link rel="prefetch" href="/ts-translate/assets/js/10.06950121.js"><link rel="prefetch" href="/ts-translate/assets/js/11.6381239b.js"><link rel="prefetch" href="/ts-translate/assets/js/12.8176b810.js"><link rel="prefetch" href="/ts-translate/assets/js/13.0a03fbf3.js"><link rel="prefetch" href="/ts-translate/assets/js/14.3482aea1.js"><link rel="prefetch" href="/ts-translate/assets/js/15.7831b050.js"><link rel="prefetch" href="/ts-translate/assets/js/16.2e5641fb.js"><link rel="prefetch" href="/ts-translate/assets/js/17.caa1f0c3.js"><link rel="prefetch" href="/ts-translate/assets/js/18.33f52e19.js"><link rel="prefetch" href="/ts-translate/assets/js/19.8756dd76.js"><link rel="prefetch" href="/ts-translate/assets/js/20.cfed5059.js"><link rel="prefetch" href="/ts-translate/assets/js/21.090f26df.js"><link rel="prefetch" href="/ts-translate/assets/js/22.ff9d5ff1.js"><link rel="prefetch" href="/ts-translate/assets/js/23.9732edd0.js"><link rel="prefetch" href="/ts-translate/assets/js/24.0ce34daf.js"><link rel="prefetch" href="/ts-translate/assets/js/25.240c5ec5.js"><link rel="prefetch" href="/ts-translate/assets/js/26.ece5b4f8.js"><link rel="prefetch" href="/ts-translate/assets/js/28.4984b1b2.js"><link rel="prefetch" href="/ts-translate/assets/js/29.6cbf69a3.js"><link rel="prefetch" href="/ts-translate/assets/js/3.572305aa.js"><link rel="prefetch" href="/ts-translate/assets/js/30.21d3e389.js"><link rel="prefetch" href="/ts-translate/assets/js/31.e611e503.js"><link rel="prefetch" href="/ts-translate/assets/js/32.5d9d0c75.js"><link rel="prefetch" href="/ts-translate/assets/js/33.2cb939dd.js"><link rel="prefetch" href="/ts-translate/assets/js/34.f373a061.js"><link rel="prefetch" href="/ts-translate/assets/js/35.9d601f8b.js"><link rel="prefetch" href="/ts-translate/assets/js/36.45e2645f.js"><link rel="prefetch" href="/ts-translate/assets/js/37.ec9011fa.js"><link rel="prefetch" href="/ts-translate/assets/js/38.ecaf875b.js"><link rel="prefetch" href="/ts-translate/assets/js/39.79652b75.js"><link rel="prefetch" href="/ts-translate/assets/js/4.202d41bd.js"><link rel="prefetch" href="/ts-translate/assets/js/40.dfeb8b60.js"><link rel="prefetch" href="/ts-translate/assets/js/41.19371e04.js"><link rel="prefetch" href="/ts-translate/assets/js/42.12a43247.js"><link rel="prefetch" href="/ts-translate/assets/js/43.08babc31.js"><link rel="prefetch" href="/ts-translate/assets/js/5.7ad19b7d.js"><link rel="prefetch" href="/ts-translate/assets/js/6.f507dfa3.js"><link rel="prefetch" href="/ts-translate/assets/js/7.61be865b.js"><link rel="prefetch" href="/ts-translate/assets/js/8.b7b7c55c.js"><link rel="prefetch" href="/ts-translate/assets/js/9.59f9442d.js">
    <link rel="stylesheet" href="/ts-translate/assets/css/0.styles.0a5bcfed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ts-translate/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript手册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/ts-translate/handbook/01-Basic.html" class="sidebar-link">一、基本类型</a></li><li><a href="/ts-translate/handbook/02-VariableDecorations.html" class="sidebar-link">二、变量声明</a></li><li><a href="/ts-translate/handbook/03-Interface.html" class="sidebar-link">三、Interface 接口</a></li><li><a href="/ts-translate/handbook/04-Class.html" class="sidebar-link">四、类</a></li><li><a href="/ts-translate/handbook/05-Function.html" class="sidebar-link">五、函数</a></li><li><a href="/ts-translate/handbook/06-Generics.html" class="sidebar-link">六、泛型</a></li><li><a href="/ts-translate/handbook/07-Enums.html" class="sidebar-link">七、枚举</a></li><li><a href="/ts-translate/handbook/08-TypeInference.html" class="sidebar-link">八、类型引用</a></li><li><a href="/ts-translate/handbook/09-TypeCompatibility.html" class="sidebar-link">九、兼容性</a></li><li><a href="/ts-translate/handbook/10-AdvanceTypes.html" class="active sidebar-link">十、增强类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#交叉类型-intersection-types" class="sidebar-link">交叉类型 Intersection Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#union-types" class="sidebar-link">Union Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#type-guards-and-differentiating-types" class="sidebar-link">Type Guards and Differentiating Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#user-defined-type-guards" class="sidebar-link">User-Defined Type Guards</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#typeof-type-guards" class="sidebar-link">typeof type guards</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#instanceof-type-guards" class="sidebar-link">instanceof type guards</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#nullable-types" class="sidebar-link">Nullable types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#optional-parameters-and-properties" class="sidebar-link">Optional parameters and properties</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#type-guards-and-type-assertions" class="sidebar-link">Type guards and type assertions</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#type-aliases" class="sidebar-link">Type Aliases</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#interfaces-vs-type-aliases" class="sidebar-link">Interfaces vs. Type Aliases</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#string-literal-types" class="sidebar-link">String Literal Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#numeric-literal-types" class="sidebar-link">Numeric Literal Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#enum-member-types" class="sidebar-link">Enum Member Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#discriminated-unions" class="sidebar-link">Discriminated Unions</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#exhaustiveness-checking" class="sidebar-link">Exhaustiveness checking</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#polymorphic-this-types" class="sidebar-link">Polymorphic this types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#index-types" class="sidebar-link">Index types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#index-types-and-index-signatures" class="sidebar-link">Index types and index signatures</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#mapped-types" class="sidebar-link">Mapped types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#inference-from-mapped-types" class="sidebar-link">Inference from mapped types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#conditional-types" class="sidebar-link">Conditional Types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#distributive-conditional-types" class="sidebar-link">Distributive conditional types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#type-inference-in-conditional-types" class="sidebar-link">Type inference in conditional types</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/10-AdvanceTypes.html#predefined-conditional-types" class="sidebar-link">Predefined conditional types</a></li></ul></li><li><a href="/ts-translate/handbook/11-Symbols.html" class="sidebar-link">十一、Symbol</a></li><li><a href="/ts-translate/handbook/12-IteratorAndGenerators.html" class="sidebar-link">十二、可迭代性 Iterables</a></li><li><a href="/ts-translate/handbook/13-Modules.html" class="sidebar-link">十三、模块</a></li><li><a href="/ts-translate/handbook/14-Namespaces.html" class="sidebar-link">十四、命名空间</a></li><li><a href="/ts-translate/handbook/15-NameSpacesModules.html" class="sidebar-link">十五、命名空间与模块</a></li><li><a href="/ts-translate/handbook/16-ModulesResolution.html" class="sidebar-link">十六、模块解析</a></li><li><a href="/ts-translate/handbook/17-DelarationMerging.html" class="sidebar-link">十七、声明合并</a></li><li><a href="/ts-translate/handbook/18-JSX.html" class="sidebar-link">十八、JSX</a></li><li><a href="/ts-translate/handbook/19-Decorators.html" class="sidebar-link">十九、修饰器</a></li><li><a href="/ts-translate/handbook/20-Mixins.html" class="sidebar-link">二十、混入</a></li><li><a href="/ts-translate/handbook/21-TripleSlashDirectives.html" class="sidebar-link">二十一、三斜线指令</a></li><li><a href="/ts-translate/handbook/22-JSDocSupportedTypes.html" class="sidebar-link">二十二、类型检查JavaScript文件</a></li><li><a href="/ts-translate/handbook/23-UtilityTypes.html" class="sidebar-link">二十三、联合类型</a></li><li><a href="/ts-translate/handbook/24-TypescriptIgnore.html" class="sidebar-link">二十四、TypeScript 类型忽略</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="十、增强类型"><a href="#十、增强类型" class="header-anchor">#</a> 十、增强类型</h1> <p><a href="#intersection-types">Intersection Types</a></p> <p><a href="#union-types">Union Types</a></p> <p><a href="#type-guards-and-differentiating-types">Type Guards and Differentiating Types</a></p> <ul><li><a href="#user-defined-type-guards">User-Defined Type Guards</a> <ul><li><a href="#using-type-predicates">Using type predicates</a></li> <li><a href="#using-the-in-operator">Using the <code>in</code> operator</a></li></ul></li> <li><a href="#typeof-type-guards"><code>typeof</code> type guards</a></li> <li><a href="#instanceof-type-guards"><code>instanceof</code> type guards</a></li></ul> <p><a href="#nullable-types">Nullable types</a></p> <ul><li><a href="#optional-parameters-and-properties">Optional parameters and properties</a></li> <li><a href="#type-guards-and-type-assertions">Type guards and type assertions</a></li></ul> <p><a href="#type-aliases">Type Aliases</a></p> <ul><li><a href="#interfaces-vs-type-aliases">Interfaces vs. Type Aliases</a></li></ul> <p><a href="#string-literal-types">String Literal Types</a></p> <p><a href="#numeric-literal-types">Numeric Literal Types</a></p> <p><a href="#enum-member-types">Enum Member Types</a></p> <p><a href="#discriminated-unions">Discriminated Unions</a></p> <ul><li><a href="#exhaustiveness-checking">Exhaustiveness checking</a></li></ul> <p><a href="#polymorphic-this-types">Polymorphic <code>this</code> types</a></p> <p><a href="#index-types">Index types</a></p> <ul><li><a href="#index-types-and-index-signatures">Index types and index signatures</a></li></ul> <p><a href="#mapped-types">Mapped types</a></p> <ul><li><a href="#inference-from-mapped-types">Inference from mapped types</a></li></ul> <p><a href="#conditional-types">Conditional Types</a></p> <ul><li><a href="#distributive-conditional-types">Distributive conditional types</a></li> <li><a href="#type-inference-in-conditional-types">Type inference in conditional types</a></li> <li><a href="#predefined-conditional-types">Predefined conditional types</a></li></ul> <h2 id="交叉类型-intersection-types"><a href="#交叉类型-intersection-types" class="header-anchor">#</a> 交叉类型 Intersection Types</h2> <p>交集类型将多个类型组合为一个。
这允许您将现有类型添加到一起，以获得一个具有所需所有功能的单一类型。
例如，' Person &amp; Serializable &amp; Loggable '是' Person ' *和' Serializable ' *和' Loggable '。
这意味着该类型的对象将拥有所有这三种类型的所有成员。</p> <p>您将主要看到交集类型用于mixin和其他概念，它们不适合经典的面向对象模型。
(JavaScript中有很多这样的代码!)
下面是一个简单的例子，展示了如何创建一个mixin:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> extend<span class="token operator">&lt;</span>First<span class="token punctuation">,</span> Second<span class="token operator">&gt;</span><span class="token punctuation">(</span>first<span class="token operator">:</span> First<span class="token punctuation">,</span> second<span class="token operator">:</span> Second<span class="token punctuation">)</span><span class="token operator">:</span> First <span class="token operator">&amp;</span> Second <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result<span class="token operator">:</span> Partial<span class="token operator">&lt;</span>First <span class="token operator">&amp;</span> Second<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> prop <span class="token keyword">in</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span>result <span class="token keyword">as</span> First<span class="token punctuation">)</span><span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> first<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> prop <span class="token keyword">in</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>second<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span>result <span class="token keyword">as</span> Second<span class="token punctuation">)</span><span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> second<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result <span class="token keyword">as</span> First <span class="token operator">&amp;</span> Second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">public</span> name<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Loggable</span> <span class="token punctuation">{</span>
    <span class="token function">log</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConsoleLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Loggable</span> <span class="token punctuation">{</span>
    <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, I'm </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> jim <span class="token operator">=</span> <span class="token function">extend</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Jim'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ConsoleLogger</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
jim<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>jim<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="union-types"><a href="#union-types" class="header-anchor">#</a> Union Types</h2> <p>联合类型与交集类型密切相关，但是它们的使用非常不同。
有时，您会遇到一个库，它期望参数是“number”或“string”。
以下面的函数为例:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * Takes a string and adds &quot;padding&quot; to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */</span>
<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns &quot;    Hello world&quot;</span>
</code></pre></div><p>' padLeft '的问题是其' padding '参数的类型为' any '。
这意味着我们可以用一个既不是“number”也不是“string”的参数来调用它，但是TypeScript不会有问题。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> indentedString <span class="token operator">=</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// passes at compile time, fails at runtime.</span>
</code></pre></div><p>在传统的面向对象代码中，我们可以通过创建类型层次结构来抽象这两种类型。
虽然这是更明确的，但也有点过头了。
“padLeft”的原始版本的一个优点是，我们可以只传递基本类型。
这意味着用法简单明了。
如果我们只是尝试使用在其他地方已经存在的函数，这种新方法也不会有帮助。</p> <p>我们可以使用一个<em>union类型</em>来代替' any '作为' padding '参数:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * Takes a string and adds &quot;padding&quot; to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */</span>
<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> indentedString <span class="token operator">=</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// errors during compilation</span>
</code></pre></div><p>union类型描述可以是几种类型之一的值。
我们使用竖线(' | ')来分隔每个类型，因此' number | string | boolean '是可以是' number '、' string '或' boolean '的值的类型。</p> <p>如果我们有一个具有union类型的值，那么我们只能访问union中所有类型所共有的成员。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>
    <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Fish</span> <span class="token punctuation">{</span>
    <span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Fish <span class="token operator">|</span> Bird <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pet<span class="token punctuation">.</span><span class="token function">layEggs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// okay</span>
pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// errors</span>
</code></pre></div><p>联合类型在这里可能有点棘手，但它只是需要一点直觉来适应。
如果一个值的类型是‘a | B’，那么我们只能确定‘a’*和‘B’都有它的成员。
在本例中，“Bird”有一个名为“fly”的成员。
我们不能确定输入为' Bird | Fish '的变量是否有' fly '方法。
如果变量在运行时是一个' Fish '，那么调用' pet.fly() '将失败。</p> <h2 id="type-guards-and-differentiating-types"><a href="#type-guards-and-differentiating-types" class="header-anchor">#</a> Type Guards and Differentiating Types</h2> <p>当值可以在它们所承担的类型中重叠时，联合类型对于建模非常有用。
当我们需要知道我们是否有一条“鱼”时，会发生什么?
JavaScript中区分两个可能值的常用习惯用法是检查成员的存在。
如前所述，您只能访问保证存在于union类型的所有组成部分中的成员。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Each of these property accesses will cause an error</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pet<span class="token punctuation">.</span>swim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pet<span class="token punctuation">.</span>fly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了让相同的代码工作，我们需要使用类型断言:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> pet <span class="token operator">=</span> <span class="token function">getSmallPet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pet <span class="token keyword">as</span> Fish<span class="token punctuation">)</span><span class="token punctuation">.</span>swim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>pet <span class="token keyword">as</span> Fish<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pet <span class="token keyword">as</span> Bird<span class="token punctuation">)</span><span class="token punctuation">.</span>fly<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>pet <span class="token keyword">as</span> Bird<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="user-defined-type-guards"><a href="#user-defined-type-guards" class="header-anchor">#</a> User-Defined Type Guards</h2> <p>注意，我们必须多次使用类型断言。
如果我们执行了检查，我们就可以知道每个分支中的“pet”的类型，那就更好了。</p> <p>碰巧TypeScript有一个叫做“type guard”的东西。
类型保护是执行运行时检查以确保在某些范围内的类型的表达式。</p> <h3 id="using-type-predicates"><a href="#using-type-predicates" class="header-anchor">#</a> Using type predicates</h3> <p>要定义一个类型保护，我们只需要定义一个函数，它的返回类型是一个<em>type谓词</em>:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">isFish</span><span class="token punctuation">(</span><span class="token parameter">pet<span class="token operator">:</span> Fish <span class="token operator">|</span> Bird</span><span class="token punctuation">)</span><span class="token operator">:</span> pet <span class="token keyword">is</span> Fish <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>pet <span class="token keyword">as</span> Fish<span class="token punctuation">)</span><span class="token punctuation">.</span>swim <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在本例中，‘pet is Fish’是我们的类型谓词。
谓词采用‘parameterName is Type’的形式，其中‘parameterName’必须是当前函数签名中的参数名称。</p> <p>任何时候使用变量调用‘isFish’时，如果原始类型兼容，TypeScript就会将该变量“缩小”到特定类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// Both calls to 'swim' and 'fly' are now okay.</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFish</span><span class="token punctuation">(</span>pet<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
    pet<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>请注意，TypeScript不仅知道“pet”是“if”分支中的“Fish”;
它还知道，在else分支中，您<em>没有</em>“鱼”，所以您必须有“鸟”。</p> <h3 id="using-the-in-operator"><a href="#using-the-in-operator" class="header-anchor">#</a> Using the <code>in</code> operator</h3> <p>' in '操作符现在充当类型的窄化表达式。</p> <p>x ' ' n的表情,“n”是一个字符串或字符串类型和“x”是一个联合类型,“真正的”分支狭窄类型的一个可选的或必需的属性“n”,和“false”分支狭窄类型的一个可选的或丢失的财产“n”。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter">pet<span class="token operator">:</span> Fish <span class="token operator">|</span> Bird</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;swim&quot;</span> <span class="token keyword">in</span> pet<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> pet<span class="token punctuation">.</span><span class="token function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> pet<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="typeof-type-guards"><a href="#typeof-type-guards" class="header-anchor">#</a> <code>typeof</code> type guards</h2> <p>让我们回过头来编写使用联合类型的<code>padLeft</code>版本的代码。
我们可以使用类型谓词编写它，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">isNumber</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isString</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span><span class="token operator">:</span> x <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNumber</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>padding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，必须定义一个函数来确定类型是否为原始类型，这很麻烦。
幸运的是，您不需要将<code>typeof x ===“ number”</code>抽象到其自己的函数中，因为TypeScript会自己将其识别为类型保护。
这意味着我们可以内联编写这些检查。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">padLeft</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> padding<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>padding <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> padding <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> padding <span class="token operator">+</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Expected string or number, got '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>padding<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">'.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些*<code>typeof</code>类型防护*有两种不同的形式：“ typeof v ===” typename“<code>和</code>typeof v！==” typename“<code>，其中” typename“</code>必须为” number“<code>。 ，</code>“ string”<code>，</code>“ boolean”<code>或</code>“ symbol”`。
虽然TypeScript不会阻止您与其他字符串进行比较，但该语言不会将这些表达式识别为类型保护。</p> <h2 id="instanceof-type-guards"><a href="#instanceof-type-guards" class="header-anchor">#</a> <code>instanceof</code> type guards</h2> <p>如果您已经阅读过<code>typeof</code>类型防护，并且熟悉JavaScript中的<code>instanceof</code>运算符，那么您可能对本节的内容有所了解。</p> <ul><li>instanceof`类型防护*是一种使用其构造函数缩小类型的方法。
例如，让我们借用前面的工业字符串填充器示例：</li></ul> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>
    <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">SpaceRepeatingPadder</span> <span class="token keyword">implements</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> numSpaces<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>numSpaces <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">StringPadder</span> <span class="token keyword">implements</span> <span class="token class-name">Padder</span> <span class="token punctuation">{</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> value<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token function">getPaddingString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.5</span> <span class="token operator">?</span>
        <span class="token keyword">new</span> <span class="token class-name">SpaceRepeatingPadder</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">:</span>
        <span class="token keyword">new</span> <span class="token class-name">StringPadder</span><span class="token punctuation">(</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Type is 'SpaceRepeatingPadder | StringPadder'</span>
<span class="token keyword">let</span> padder<span class="token operator">:</span> Padder <span class="token operator">=</span> <span class="token function">getRandomPadder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>padder <span class="token keyword">instanceof</span> <span class="token class-name">SpaceRepeatingPadder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    padder<span class="token punctuation">;</span> <span class="token comment">// type narrowed to 'SpaceRepeatingPadder'</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>padder <span class="token keyword">instanceof</span> <span class="token class-name">StringPadder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    padder<span class="token punctuation">;</span> <span class="token comment">// type narrowed to 'StringPadder'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>“ instanceof”的右侧需要是一个构造函数，而TypeScript将缩小为：</p> <p>1.函数的原型属性的类型（如果其类型不是any）
2.由该类型的构造签名返回的类型的并集</p> <p>以该顺序。</p> <h2 id="nullable-types"><a href="#nullable-types" class="header-anchor">#</a> Nullable types</h2> <p>TypeScript具有两种特殊类型，分别为null和undefined，其值分别为null和undefined。
我们在[基本类型]部分()./Basic%20Types.md）中简要提到了这些内容。
默认情况下，类型检查器认为<code>null'和</code>undefined`可分配给任何东西。
实际上，“ null”和“ undefined”是每种类型的有效值。
这意味着即使您想阻止它们，也不能<em>停止</em>将它们分配给任何类型。
<a href="https://en.wikipedia.org/wiki/Null_pointer#History" target="_blank" rel="noopener noreferrer">“ null”的发明者Tony Hoare将此称为他的““十亿美元错误”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>--strictNullChecks标志可解决此问题：声明变量时，它不会自动包含<code>null</code>或<code>undefined</code>。
您可以使用并集类型显式包括它们：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// error, 'null' is not assignable to 'string'</span>
<span class="token keyword">let</span> sn<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">;</span>
sn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>

sn <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// error, 'undefined' is not assignable to 'string | null'</span>
</code></pre></div><p>请注意，TypeScript对null和undefined的区别对待是为了匹配JavaScript语义。
<code>字符串| null与</code>string |是不同的类型。 undefined<code>和</code>string |未定义空`。</p> <p>从TypeScript 3.7及更高版本开始，您可以使用[可选链接]（/ docs / handbook / release-notes / typescript-3-7.html＃optional-chaining）来简化可空类型的使用。</p> <h2 id="optional-parameters-and-properties"><a href="#optional-parameters-and-properties" class="header-anchor">#</a> Optional parameters and properties</h2> <p>使用<code>--strictNullChecks</code>，可选参数会自动添加<code>|未定义</code>：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, 'null' is not assignable to 'number | undefined'</span>
</code></pre></div><p>可选属性也是如此：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    b<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// error, 'undefined' is not assignable to 'number'</span>
c<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">13</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
c<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// error, 'null' is not assignable to 'number | undefined'</span>
</code></pre></div><h2 id="type-guards-and-type-assertions"><a href="#type-guards-and-type-assertions" class="header-anchor">#</a> Type guards and type assertions</h2> <p>由于可为空的类型是通过联合实现的，因此您需要使用类型保护来摆脱“ null”。
幸运的是，这与您在JavaScript中编写的代码相同：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">sn<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sn <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;default&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sn<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>null消除在这里非常明显，但是您也可以使用terser运算符：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">sn<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> sn <span class="token operator">||</span> <span class="token string">&quot;default&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果编译器无法消除“ null”或“ undefined”，则可以使用类型声明运算符手动删除它们。
语法是后缀<code>！</code>：<code>identifier！</code>从<code>identifier</code>类型中删除<code>null</code>和<code>undefined</code>：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">broken</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token parameter">epithet<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.  the '</span> <span class="token operator">+</span> epithet<span class="token punctuation">;</span> <span class="token comment">// error, 'name' is possibly null</span>
  <span class="token punctuation">}</span>
  name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token string">&quot;great&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fixed</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token parameter">epithet<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.  the '</span> <span class="token operator">+</span> epithet<span class="token punctuation">;</span> <span class="token comment">// ok</span>
  <span class="token punctuation">}</span>
  name <span class="token operator">=</span> name <span class="token operator">||</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">postfix</span><span class="token punctuation">(</span><span class="token string">&quot;great&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该示例在此处使用嵌套函数，因为编译器无法消除嵌套函数内部的空值（立即调用的函数表达式除外）。
这是因为它无法跟踪对嵌套函数的所有调用，尤其是从外部函数返回它时。
不知道函数在哪里被调用，就无法知道主体执行时“ name”的类型。</p> <h2 id="type-aliases"><a href="#type-aliases" class="header-anchor">#</a> Type Aliases</h2> <p>类型别名为类型创建新名称。
类型别名有时类似于接口，但是可以命名原语，并集，元组和其他必须手动编写的其他类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Name <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token function-variable function">NameResolver</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> NameOrResolver <span class="token operator">=</span> Name <span class="token operator">|</span> NameResolver<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token operator">:</span> NameOrResolver</span><span class="token punctuation">)</span><span class="token operator">:</span> Name <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> n <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">n</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>别名实际上并不会创建新的类型-它会创建一个新的* name *来引用该类型。
虽然可以将原语用作文档的一种形式，但它并不是非常有用。</p> <p>就像接口一样，类型别名也可以是通用的-我们可以添加类型参数并在别名声明的右侧使用它们：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Container<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们还可以在属性中使用类型别名来引用自身：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    left<span class="token operator">:</span> Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    right<span class="token operator">:</span> Tree<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与交叉点类型一起，我们可以制作一些漂亮的弯腰类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> LinkedList<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> next<span class="token operator">:</span> LinkedList<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> people<span class="token operator">:</span> LinkedList<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>next<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> people<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
</code></pre></div><p>但是，类型别名不可能出现在声明右侧的任何其他位置：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Yikes <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Yikes<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
</code></pre></div><h2 id="interfaces-vs-type-aliases"><a href="#interfaces-vs-type-aliases" class="header-anchor">#</a> Interfaces vs. Type Aliases</h2> <p>如前所述，类型别名可以起到类似接口的作用。但是，有一些细微的差异。</p> <p>一个区别是接口创建了一个新名称，该名称在任何地方都可以使用。
类型别名不会创建新名称-例如，错误消息不会使用别名。
在下面的代码中，将鼠标悬停在编辑器中的“ interfaced”上将显示其返回“ Interface”，但将显示“ aliased”返回对象文字类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Alias <span class="token operator">=</span> <span class="token punctuation">{</span> num<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Interface</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">aliased</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> Alias</span><span class="token punctuation">)</span><span class="token operator">:</span> Alias<span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">interfaced</span><span class="token punctuation">(</span><span class="token parameter">arg<span class="token operator">:</span> Interface</span><span class="token punctuation">)</span><span class="token operator">:</span> Interface<span class="token punctuation">;</span>
</code></pre></div><p>在较旧的TypeScript版本中，不能从中扩展或实现类型别名（也不能扩展/实现其他类型）。从2.7版开始，可以通过创建新的交集类型（例如， `type Cat = Animal＆{purrs：true}。</p> <p>因为<a href="https://en.wikipedia.org/wiki/Open/closed_principl" target="_blank" rel="noopener noreferrer">软件的理想属性正在向扩展开放<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所以如果可能，应该始终在类型别名上使用接口。</p> <p>另一方面，如果您无法使用接口表达某种形状，而需要使用并集或元组类型，则通常使用类型别名。</p> <h2 id="string-literal-types"><a href="#string-literal-types" class="header-anchor">#</a> String Literal Types</h2> <p>字符串文字类型允许您指定字符串必须具有的确切值。
在实践中，字符串文字类型与联合类型，类型保护和类型别名很好地结合在一起。
您可以将这些功能一起使用，以获得类似于字符串的枚举行为。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Easing <span class="token operator">=</span> <span class="token string">&quot;ease-in&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;ease-out&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;ease-in-out&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">UIElement</span> <span class="token punctuation">{</span>
    <span class="token function">animate</span><span class="token punctuation">(</span><span class="token parameter">dx<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> dy<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> easing<span class="token operator">:</span> Easing</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&quot;ease-in&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&quot;ease-out&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>easing <span class="token operator">===</span> <span class="token string">&quot;ease-in-out&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// error! should not pass null or undefined.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> button <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UIElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
button<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;ease-in&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
button<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;uneasy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: &quot;uneasy&quot; is not allowed here</span>
</code></pre></div><p>您可以传递三个允许的字符串中的任何一个，但是任何其他字符串都会给出错误</p> <div class="language-text extra-class"><pre class="language-text"><code>Argument of type '&quot;uneasy&quot;' is not assignable to parameter of type '&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;'
</code></pre></div><p>可以使用相同的方式使用字符串文字类型来区分重载：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span>tagName<span class="token operator">:</span> <span class="token string">&quot;img&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> HTMLImageElement<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span>tagName<span class="token operator">:</span> <span class="token string">&quot;input&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> HTMLInputElement<span class="token punctuation">;</span>
<span class="token comment">// ... more overloads ...</span>
<span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">tagName<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span><span class="token operator">:</span> Element <span class="token punctuation">{</span>
    <span class="token comment">// ... code goes here ...</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="numeric-literal-types"><a href="#numeric-literal-types" class="header-anchor">#</a> Numeric Literal Types</h2> <p>TypeScript还具有数字文字类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">rollDice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span> <span class="token number">6</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这些很少是明确编写的，但是在缩小问题范围时可能很有用，并且可以捕获错误：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token number">1</span> <span class="token operator">||</span> x <span class="token operator">!==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//         ~~~~~~~</span>
        <span class="token comment">// Operator '!==' cannot be applied to types '1' and '2'.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>换句话说，“ x”与“ 2”进行比较时必须为“ 1”，这意味着上述检查正在进行无效的比较。</p> <h2 id="enum-member-types"><a href="#enum-member-types" class="header-anchor">#</a> Enum Member Types</h2> <p>如[我们的枚举部分]（./ Enums.md＃union-enums-and-enum-member-types）中所述，当每个成员都进行文字初始化时，枚举成员具有类型。</p> <p>在很多时候，当我们谈论“单身类型”时，我们既指枚举成员类型，也指数字/字符串文字类型，尽管许多用户会交替使用“单身类型”和“文字类型”。</p> <h2 id="discriminated-unions"><a href="#discriminated-unions" class="header-anchor">#</a> Discriminated Unions</h2> <p>您可以组合单例类型，联合类型，类型保护和类型别名来构建称为* discriminated unions <em>（也称为</em> tagged Union <em>或</em> algebraic数据类型*）的高级模式。
区分联合在函数式编程中很有用。
某些语言会自动为您区分工会；相反，TypeScript建立在当今存在的JavaScript模式上。
共有三种成分：</p> <p>1.具有共同的单例类型属性的类型-* discriminant <em>。
2.类型别名，采用这些类型的并集-</em> union *。
3.在公共属性上键入防护。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Square</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> <span class="token string">&quot;square&quot;</span><span class="token punctuation">;</span>
    size<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> <span class="token string">&quot;rectangle&quot;</span><span class="token punctuation">;</span>
    width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    height<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">Circle</span> <span class="token punctuation">{</span>
    kind<span class="token operator">:</span> <span class="token string">&quot;circle&quot;</span><span class="token punctuation">;</span>
    radius<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先，我们声明将要联合的接口。
每个接口都有一个“ kind”属性，具有不同的字符串文字类型。
kind属性称为* discriminant <em>或</em> tag *。
其他属性特定于每个接口。
请注意，接口当前不相关。
让我们将它们合并为一个工会：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Shape <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle <span class="token operator">|</span> Circle<span class="token punctuation">;</span>
</code></pre></div><p>Now let's use the discriminated union:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="exhaustiveness-checking"><a href="#exhaustiveness-checking" class="header-anchor">#</a> Exhaustiveness checking</h2> <p>我们希望编译器告诉我们何时不涵盖已区分联合的所有变体。
例如，如果我们在“形状”中添加“三角”，我们还需要更新“区域”：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Shape <span class="token operator">=</span> Square <span class="token operator">|</span> Rectangle <span class="token operator">|</span> Circle <span class="token operator">|</span> Triangle<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// should error here - we didn't handle case &quot;triangle&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有两种方法可以做到这一点。
首先是打开--strictNullChecks并指定返回类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> Shape</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span> <span class="token comment">// error: returns number | undefined</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为switch不再穷举，所以TypeScript知道该函数有时可能返回undefined。
如果您有明确的返回类型<code>number</code>，那么您将得到一个错误，指出返回类型实际上是<code>number |。未定义</code>。
但是，这种方法非常微妙，此外，--strictNullChecks并不总是适用于旧代码。</p> <p>第二种方法使用编译器用来检查穷举的<code>never</code>类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">assertNever</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">never</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Unexpected object: &quot;</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> Shape</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>kind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">&quot;square&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>size <span class="token operator">*</span> s<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;rectangle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> s<span class="token punctuation">.</span>height <span class="token operator">*</span> s<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">&quot;circle&quot;</span><span class="token operator">:</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">*</span> s<span class="token punctuation">.</span>radius <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span> <span class="token keyword">return</span> <span class="token function">assertNever</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error here if there are missing cases</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，“ assertNever”检查“ s”的类型是否为“ never”，即所有其他案例都已删除后剩下的类型。
如果您忘记了一个案例，那么<code>s</code>将具有实型，并且您将得到类型错误。
此方法需要您定义一个额外的函数，但是当您忘记它时，它会更加明显。</p> <h2 id="polymorphic-this-types"><a href="#polymorphic-this-types" class="header-anchor">#</a> Polymorphic <code>this</code> types</h2> <p>多态的“此”类型表示一种类型，它是包含的类或接口的“子类型”。
这称为* F *有界多态性。
例如，这使得分层流利的接口更易于表达。
拿一个简单的计算器，在每次操作后返回“ this”：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">protected</span> value<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">add</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">+=</span> operand<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">multiply</span><span class="token punctuation">(</span>operand<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">this</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">*=</span> operand<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... other operations go here ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicCalculator</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>由于该类使用“ this”类型，因此您可以对其进行扩展，而新类可以使用旧方法而无需进行任何更改。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">ScientificCalculator</span> <span class="token keyword">extends</span> <span class="token class-name">BasicCalculator</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter">value <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ... other operations go here ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScientificCalculator</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">currentValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>没有“ this”类型，“ ScientificCalculator”将无法扩展“ BasicCalculator”并保持流畅的界面。
<code>multiply</code>将返回<code>BasicCalculator</code>，它没有<code>sin</code>方法。
但是，对于“ this”类型，“ multiply”会返回“ this”，此处为“ ScientificCalculator”。</p> <h2 id="index-types"><a href="#index-types" class="header-anchor">#</a> Index types</h2> <p>With index types, you can get the compiler to check code that uses dynamic property names.
For example, a common JavaScript pattern is to pick a subset of properties from an object:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">pluck</span><span class="token punctuation">(</span><span class="token parameter">o<span class="token punctuation">,</span> propertyNames</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> propertyNames<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">n</span> <span class="token operator">=&gt;</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是使用<strong>索引类型查询</strong>和<strong>索引访问</strong>运算符在TypeScript中编写和使用此函数的方式：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> pluck<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> propertyNames<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> propertyNames<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">n</span> <span class="token operator">=&gt;</span> o<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
    manufacturer<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    model<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    year<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taxi<span class="token operator">:</span> Car <span class="token operator">=</span> <span class="token punctuation">{</span>
    manufacturer<span class="token operator">:</span> <span class="token string">'Toyota'</span><span class="token punctuation">,</span>
    model<span class="token operator">:</span> <span class="token string">'Camry'</span><span class="token punctuation">,</span>
    year<span class="token operator">:</span> <span class="token number">2014</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Manufacturer and model are both of type string,</span>
<span class="token comment">// so we can pluck them both into a typed string array</span>
<span class="token keyword">let</span> makeAndModel<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'manufacturer'</span><span class="token punctuation">,</span> <span class="token string">'model'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// If we try to pluck model and year, we get an</span>
<span class="token comment">// array of a union type: (string | number)[]</span>
<span class="token keyword">let</span> modelYear <span class="token operator">=</span> <span class="token function">pluck</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'model'</span><span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>编译器检查“ manufacturer”和“ model”是否实际上是“ Car”上的属性。
该示例引入了几个新型运算符。
首先是<code>keyof T</code>，索引类型查询运算符**。
对于任何类型的“ T”，“ keyof T”是“ T”的已知公共属性名称的并集。
例如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> carProps<span class="token operator">:</span> <span class="token keyword">keyof</span> Car<span class="token punctuation">;</span> <span class="token comment">// the union of ('manufacturer' | 'model' | 'year')</span>
</code></pre></div><p><code>keyof Car</code>与'manufacturer'完全可互换| '模型'| 'year'<code>。 不同之处在于，如果您向</code>Car<code>添加另一个属性，例如</code>ownersAddress：string<code>，则</code>keyof Car<code>将自动更新为</code>'manufacturer'|。 '模型'| '年'| “ ownersAddress”。
而且，您可以在“ pluck”之类的通用上下文中使用“ keyof”，在这种情况下您可能无法提前知道属性名称。
这意味着编译器将检查您是否将正确的属性名称集传递给<code>pluck</code>：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'</span>
<span class="token function">pluck</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token string">'unknown'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">/</span>
</code></pre></div><p>第二个运算符是“ T [K]”，即索引访问运算符**。
在此，类型语法反映了表达式语法。
这意味着<code>person ['name']</code>的类型为<code>Person ['name']</code>-在我们的示例中仅为<code>string</code>。
但是，就像索引类型查询一样，您可以在通用上下文中使用“ T [K]”，这才是其真正的生命所在。
您只需要确保类型变量“ K”扩展了T的key。
这是另一个名为<code>getProperty</code>的函数的示例。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> getProperty<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> propertyName<span class="token operator">:</span> <span class="token constant">K</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> o<span class="token punctuation">[</span>propertyName<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// o[propertyName] is of type T[K]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在“ getProperty”中，“ o：T”和“ propertyName：K”，因此意味着“ o [propertyName]：T [K]”。
一旦返回T [K]结果，编译器将实例化密钥的实际类型，因此getProperty的返回类型将根据您请求的属性而有所不同。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token string">'manufacturer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> year<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'</span>
<span class="token keyword">let</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token function">getProperty</span><span class="token punctuation">(</span>taxi<span class="token punctuation">,</span> <span class="token string">'unknown'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="index-types-and-index-signatures"><a href="#index-types-and-index-signatures" class="header-anchor">#</a> Index types and index signatures</h2> <p>keyof和T [K]与索引签名进行交互。索引签名参数类型必须为“字符串”或“数字”。
如果您的类型具有字符串索引签名，则<code>keyof T</code>将为<code>string |。数字</code>
（而不仅仅是<code>string</code>，因为在JavaScript中您可以访问object属性
通过使用字符串（<code>object ['42'</code>]）或数字（<code>object [42]</code>））。
T [string]只是索引签名的类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> keys<span class="token operator">:</span> <span class="token keyword">keyof</span> Dictionary<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>
<span class="token keyword">let</span> value<span class="token operator">:</span> Dictionary<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre></div><p>如果您的类型带有数字索引签名，则“ keyof T”将只是“ number”。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Dictionary</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> keys<span class="token operator">:</span> <span class="token keyword">keyof</span> Dictionary<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
<span class="token keyword">let</span> value<span class="token operator">:</span> Dictionary<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error, Property 'foo' does not exist on type 'Dictionary&lt;number&gt;'.</span>
<span class="token keyword">let</span> value<span class="token operator">:</span> Dictionary<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre></div><h2 id="mapped-types"><a href="#mapped-types" class="header-anchor">#</a> Mapped types</h2> <p>一个常见的任务是采用一个现有的类型并将其每个属性设为可选：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">PersonPartial</span> <span class="token punctuation">{</span>
    name<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    age<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者我们可能想要一个只读版本：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">PersonReadonly</span> <span class="token punctuation">{</span>
    <span class="token keyword">readonly</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    <span class="token keyword">readonly</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种情况在JavaScript中经常发生，TypeScript提供了一种基于旧类型（<strong>映射类型</strong>）创建新类型的方法。
在映射类型中，新类型以相同的方式转换旧类型中的每个属性。
例如，您可以将所有属性设置为“只读”类型或可选属性。
以下是几个示例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">readonly</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>And to use it:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> PersonPartial <span class="token operator">=</span> Partial<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> ReadonlyPerson <span class="token operator">=</span> Readonly<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>请注意，此语法描述的是类型而不是成员。
如果要添加成员，则可以使用交集类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// Use this:</span>
<span class="token keyword">type</span> PartialWithNewMember<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> newMember<span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span>

<span class="token comment">// **Do not** use the following!</span>
<span class="token comment">// This is an error!</span>
<span class="token keyword">type</span> PartialWithNewMember<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  newMember<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>让我们看一下最简单的映射类型及其部分：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Keys <span class="token operator">=</span> <span class="token string">'option1'</span> <span class="token operator">|</span> <span class="token string">'option2'</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> Flags <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> Keys<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>语法类似于索引签名的语法，内部带有“ ..in”。
分为三个部分：</p> <p>1.类型变量“ K”，它依次绑定到每个属性。
2.字符串文字联合“ Keys”，其中包含要迭代的属性的名称。
3.属性的结果类型。</p> <p>在这个简单的示例中，“键”是属性名称的硬编码列表，并且属性类型始终为“布尔”，因此此映射类型等效于编写：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Flags <span class="token operator">=</span> <span class="token punctuation">{</span>
    option1<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    option2<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，实际的应用程序看起来像上面的“只读”或“部分”。
它们基于某些现有类型，并且以某种方式转换属性。
这就是<code>keyof</code>和索引访问类型的来源：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> NullablePerson <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> Person<span class="token punctuation">]</span><span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>
<span class="token keyword">type</span> PartialPerson <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> Person<span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> Person<span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre></div><p>但是拥有通用版本会更有用。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Nullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">}</span>
<span class="token keyword">type</span> Partial<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre></div><p>在这些示例中，属性列表是“ keyof T”，而结果类型是“ T [P]”的某种变体。
对于映射类型的任何常规使用，这都是一个很好的模板。
这是因为这种转换是<a href="https://en.wikipedia.org/wiki/Homomorphis" target="_blank" rel="noopener noreferrer">同态的<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这意味着映射仅适用于T的属性，而不适用于其他属性。
编译器知道在添加任何新的属性修饰符之前，它可以复制所有现有的属性修饰符。
例如，如果“ Person.name”是只读的，那么“ <code>Partial&lt;Person&gt;</code> .name”将是只读的并且是可选的。</p> <p>这是另一个示例，其中将T [P]包裹在<code>proxy&lt;T&gt;</code>类中：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Proxy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> Proxy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>o<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
   <span class="token comment">// ... wrap proxies ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> proxyProps <span class="token operator">=</span> <span class="token function">proxify</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>请注意，<code>Readonly &lt;T&gt;</code>和<code>Partial &lt;T&gt;</code>是如此有用，它们与<code>Pick</code>和<code>Record</code>一起包含在TypeScript的标准库中：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">P</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> Record<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token constant">P</span> <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>“只读”，“部分”和“选择”是同态的，而“记录”则不是同态的。
提示<code>Record</code>不是同态的，这是因为它不需要输入类型来复制以下属性：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> ThreeStringProps <span class="token operator">=</span> Record<span class="token operator">&lt;</span><span class="token string">'prop1'</span> <span class="token operator">|</span> <span class="token string">'prop2'</span> <span class="token operator">|</span> <span class="token string">'prop3'</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;</span>
</code></pre></div><p>非同态类型本质上是在创建新属性，因此它们不能从任何地方复制属性修改器。</p> <h2 id="inference-from-mapped-types"><a href="#inference-from-mapped-types" class="header-anchor">#</a> Inference from mapped types</h2> <p>既然您知道如何包装类型的属性，接下来要做的就是将它们拆包。
幸运的是，这很容易：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> unproxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token operator">:</span> Proxify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">in</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> originalProps <span class="token operator">=</span> <span class="token function">unproxify</span><span class="token punctuation">(</span>proxyProps<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>请注意，这种展开推论仅适用于同态映射类型。
如果映射的类型不是同态的，则必须为展开函数提供一个显式的类型参数。</p> <h2 id="conditional-types"><a href="#conditional-types" class="header-anchor">#</a> Conditional Types</h2> <p>TypeScript 2.8引入了“条件类型”，这增加了表达非均匀类型映射的能力。
条件类型根据表示为类型关系测试的条件选择两种可能的类型之一：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">U</span> <span class="token operator">?</span> <span class="token constant">X</span> <span class="token operator">:</span> <span class="token constant">Y</span>
</code></pre></div><p>上面的类型表示将“ T”分配给“ U”时，类型是“ X”，否则类型是“ Y”。</p> <p>条件类型<code>T扩展U？ X：Y</code>被<em>解析为X或Y或被推迟</em>因为条件取决于一个或多个类型变量。
当“ T”或“ U”包含类型变量时，是否要解析为“ X”或“ Y”，还是推迟，取决于类型系统是否具有足够的信息来推断“ T”始终可分配给U</p> <p>作为可以立即解决的某些类型的示例，我们可以看以下示例：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> f<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">boolean</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">true</span> <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token comment">// Type is 'string | number</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">)</span>

</code></pre></div><p>另一个例子是TypeName类型别名，它使用嵌套的条件类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> TypeName<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">string</span> <span class="token operator">?</span> <span class="token string">&quot;string&quot;</span> <span class="token operator">:</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">number</span> <span class="token operator">?</span> <span class="token string">&quot;number&quot;</span> <span class="token operator">:</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">boolean</span> <span class="token operator">?</span> <span class="token string">&quot;boolean&quot;</span> <span class="token operator">:</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">undefined</span> <span class="token operator">?</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">:</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Function</span> <span class="token operator">?</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">:</span>
    <span class="token string">&quot;object&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token constant">T0</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;string&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T1</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;string&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T2</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;boolean&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T3</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;function&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T4</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;object&quot;</span>
</code></pre></div><p>但是，作为一个条件条件被延迟的地方的示例（它们坚持而不是选择分支），将在以下示例中出现：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    propA<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    propB<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">function</span> f<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token operator">?</span> <span class="token builtin">string</span> <span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> foo<span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Has type 'U extends Foo ? string : number'</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// This assignment is allowed though!</span>
    <span class="token keyword">let</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面，变量“ a”具有尚未选择分支的条件类型。
当另一段代码最终调用<code>foo</code>时，它将在<code>U</code>中替换为其他类型，并且TypeScript将重新评估条件类型，确定其是否可以实际选择分支。</p> <p>同时，我们可以将条件类型分配给任何其他目标类型，只要条件的每个分支都可以分配给该目标即可。
因此，在上面的示例中，我们可以分配<code>U extend Foo吗？ string：number</code>到`string |数字”，因为无论条件求值的结果如何，它都可以是“字符串”或“数字”。</p> <h2 id="distributive-conditional-types"><a href="#distributive-conditional-types" class="header-anchor">#</a> Distributive conditional types</h2> <p>选中的类型为裸类型参数的条件类型称为<em>分布式条件类型</em>。
实例化期间，分布条件类型自动在联合类型上分布。
例如，<code>T的实例扩展U？ X：Y</code>，类型参数为<code>A | B | T的C解析为（（A扩展U？X：Y）| （B延伸U？X：Y）| （C扩展U？X：Y）</code>。</p> <h3 id="example"><a href="#example" class="header-anchor">#</a> Example</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token constant">T10</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;string&quot; | &quot;function&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T12</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;string&quot; | &quot;object&quot; | &quot;undefined&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T11</span> <span class="token operator">=</span> TypeName<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;object&quot;</span>
</code></pre></div><p>在分布条件类型的实例中，<code>T扩展了U？ X：Y</code>，条件类型中对T的引用将解析为并集类型的各个组成部分（即，*在条件类型分布在并集类型上之后，``T''是指单个组成部分）。
此外，对“ X”内的“ T”的引用还有一个附加的类型参数约束“ U”（即，“ T”被认为可分配给“ X”内的“ U”）。</p> <h3 id="example-1"><a href="#example-1" class="header-anchor">#</a> Example 1</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> BoxedValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> BoxedArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> array<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> Boxed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> BoxedArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token operator">:</span> BoxedValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token constant">T20</span> <span class="token operator">=</span> Boxed<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// BoxedValue&lt;string&gt;;</span>
<span class="token keyword">type</span> <span class="token constant">T21</span> <span class="token operator">=</span> Boxed<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// BoxedArray&lt;number&gt;;</span>
<span class="token keyword">type</span> <span class="token constant">T22</span> <span class="token operator">=</span> Boxed<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;</span>
</code></pre></div><p>注意，“ T”在“ <code>Boxed &lt;T&gt;</code>”的真实分支内具有附加约束“ any []”，因此可以将数组的元素类型称为“ T [number]”。另外，请注意在上一个示例中，条件类型如何分布在联合类型上。</p> <p>条件类型的分布属性可以方便地用于<em>过滤</em>联合类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Diff<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">U</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>  <span class="token comment">// Remove types from T that are assignable to U</span>
<span class="token keyword">type</span> Filter<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">U</span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>  <span class="token comment">// Remove types from T that are not assignable to U</span>

<span class="token keyword">type</span> <span class="token constant">T30</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;b&quot; | &quot;d&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T31</span> <span class="token operator">=</span> Filter<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;a&quot; | &quot;c&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T32</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token constant">T33</span> <span class="token operator">=</span> Filter<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// () =&gt; void</span>

<span class="token keyword">type</span> NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> Diff<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Remove null and undefined from T</span>

<span class="token keyword">type</span> <span class="token constant">T34</span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token constant">T35</span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | string[]</span>

<span class="token keyword">function</span> f1<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// Ok</span>
    y <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// Error</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> f2<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> NonNullable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// Ok</span>
    y <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// Error</span>
    <span class="token keyword">let</span> s1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// Error</span>
    <span class="token keyword">let</span> s2<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// Ok</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与映射类型结合使用时，条件类型特别有用：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> FunctionPropertyNames<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Function</span> <span class="token operator">?</span> <span class="token constant">K</span> <span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> FunctionProperties<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> FunctionPropertyNames<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> NonFunctionPropertyNames<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">Function</span> <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token operator">:</span> <span class="token constant">K</span> <span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> NonFunctionProperties<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> Pick<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> NonFunctionPropertyNames<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Part</span> <span class="token punctuation">{</span>
    id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    subparts<span class="token operator">:</span> Part<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">updatePart</span><span class="token punctuation">(</span>newName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token constant">T40</span> <span class="token operator">=</span> FunctionPropertyNames<span class="token operator">&lt;</span>Part<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;updatePart&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T41</span> <span class="token operator">=</span> NonFunctionPropertyNames<span class="token operator">&lt;</span>Part<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;id&quot; | &quot;name&quot; | &quot;subparts&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T42</span> <span class="token operator">=</span> FunctionProperties<span class="token operator">&lt;</span>Part<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// { updatePart(newName: string): void }</span>
<span class="token keyword">type</span> <span class="token constant">T43</span> <span class="token operator">=</span> NonFunctionProperties<span class="token operator">&lt;</span>Part<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// { id: number, name: string, subparts: Part[] }</span>
</code></pre></div><p>与联合和交集类型相似，条件类型不允许递归引用自己。
例如，以下是错误。</p> <h3 id="example1"><a href="#example1" class="header-anchor">#</a> Example1</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> ElementType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> ElementType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>
</code></pre></div><h2 id="type-inference-in-conditional-types"><a href="#type-inference-in-conditional-types" class="header-anchor">#</a> Type inference in conditional types</h2> <p>现在，在条件类型的<code>extends'子句中，可以有</code>infer`声明来引入要推断的类型变量。
可以在条件类型的真实分支中引用此类推断的类型变量。
同一类型变量可能有多个“推断”位置。</p> <p>例如，以下代码提取函数类型的返回类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><p>可以嵌套条件类型以形成一系列按顺序求值的模式匹配：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Unpacked<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>infer <span class="token constant">U</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token constant">U</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span>
    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Promise</span><span class="token operator">&lt;</span>infer <span class="token constant">U</span><span class="token operator">&gt;</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span>
    <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token constant">T0</span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token constant">T1</span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token constant">T2</span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token constant">T3</span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token constant">T4</span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Promise&lt;string&gt;</span>
<span class="token keyword">type</span> <span class="token constant">T5</span> <span class="token operator">=</span> Unpacked<span class="token operator">&lt;</span>Unpacked<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
</code></pre></div><p>下面的示例演示在协变量位置上同一类型变量的多个候选如何导致推断联合类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Foo<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> infer <span class="token constant">U</span><span class="token punctuation">,</span> b<span class="token operator">:</span> infer <span class="token constant">U</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token constant">T10</span> <span class="token operator">=</span> Foo<span class="token operator">&lt;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token constant">T11</span> <span class="token operator">=</span> Foo<span class="token operator">&lt;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
</code></pre></div><p>同样，在变数位置中针对同一类型变量的多个候选会导致推断相交类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Bar<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> infer <span class="token constant">U</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> infer <span class="token constant">U</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span> <span class="token operator">?</span> <span class="token constant">U</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token constant">T20</span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token constant">T21</span> <span class="token operator">=</span> Bar<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string &amp; number</span>
</code></pre></div><p>从具有多个调用签名的类型（例如，重载函数的类型）进行推断时，会从* last *签名（可能是最宽松的情况）进行推断。
无法基于参数类型列表执行重载解析。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token constant">T30</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> foo<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
</code></pre></div><p>对于常规类型参数，不能在约束子句中使用<code>infer</code>声明：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token constant">R</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">;</span>  <span class="token comment">// Error, not supported</span>
</code></pre></div><p>但是，通过擦除约束中的类型变量并改为指定条件类型，可以获得大致相同的效果：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token function-variable function">AnyFunction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">AnyFunction</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> infer <span class="token constant">R</span> <span class="token operator">?</span> <span class="token constant">R</span> <span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="predefined-conditional-types"><a href="#predefined-conditional-types" class="header-anchor">#</a> Predefined conditional types</h2> <p>TypeScript 2.8在<code>lib.d.ts</code>中添加了几个预定义的条件类型：</p> <ul><li><code>Exclude&lt;T, U&gt;</code> -- Exclude from <code>T</code> those types that are assignable to <code>U</code>.</li> <li><code>Extract&lt;T, U&gt;</code> -- Extract from <code>T</code> those types that are assignable to <code>U</code>.</li> <li><code>NonNullable&lt;T&gt;</code> -- Exclude <code>null</code> and <code>undefined</code> from <code>T</code>.</li> <li><code>ReturnType&lt;T&gt;</code> -- Obtain the return type of a function type.</li> <li><code>InstanceType&lt;T&gt;</code> -- Obtain the instance type of a constructor function type.</li></ul> <h3 id="example11"><a href="#example11" class="header-anchor">#</a> Example11</h3> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token constant">T00</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;b&quot; | &quot;d&quot;</span>
<span class="token keyword">type</span> <span class="token constant">T01</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;b&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;c&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;f&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// &quot;a&quot; | &quot;c&quot;</span>

<span class="token keyword">type</span> <span class="token constant">T02</span> <span class="token operator">=</span> Exclude<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token constant">T03</span> <span class="token operator">=</span> Extract<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// () =&gt; void</span>

<span class="token keyword">type</span> <span class="token constant">T04</span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string | number</span>
<span class="token keyword">type</span> <span class="token constant">T05</span> <span class="token operator">=</span> NonNullable<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// (() =&gt; string) | string[]</span>

<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> s <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token constant">T10</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token constant">T11</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// void</span>
<span class="token keyword">type</span> <span class="token constant">T12</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// {}</span>
<span class="token keyword">type</span> <span class="token constant">T13</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token constant">U</span> <span class="token keyword">extends</span> <span class="token class-name">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// number[]</span>
<span class="token keyword">type</span> <span class="token constant">T14</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> f1<span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// { a: number, b: string }</span>
<span class="token keyword">type</span> <span class="token constant">T15</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token constant">T16</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// never</span>
<span class="token keyword">type</span> <span class="token constant">T17</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>
<span class="token keyword">type</span> <span class="token constant">T18</span> <span class="token operator">=</span> ReturnType<span class="token operator">&lt;</span><span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>

<span class="token keyword">type</span> <span class="token constant">T20</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> <span class="token constant">C</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// C</span>
<span class="token keyword">type</span> <span class="token constant">T21</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// any</span>
<span class="token keyword">type</span> <span class="token constant">T22</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// never</span>
<span class="token keyword">type</span> <span class="token constant">T23</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>
<span class="token keyword">type</span> <span class="token constant">T24</span> <span class="token operator">=</span> InstanceType<span class="token operator">&lt;</span><span class="token builtin">Function</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// Error</span>
</code></pre></div><blockquote><p>注意：“排除”类型是建议在此处<a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458" target="_blank" rel="noopener noreferrer">Diff类型使用的正确实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。我们使用了<code>Exclude</code>这个名字来避免破坏现有的定义<code>Diff</code>的代码，而且我们觉得这个名字更好地传达了该类型的语义。</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/7/2020, 3:48:55 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ts-translate/handbook/09-TypeCompatibility.html" class="prev">
        九、兼容性
      </a></span> <span class="next"><a href="/ts-translate/handbook/11-Symbols.html">
        十一、Symbol
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ts-translate/assets/js/app.141fbb0f.js" defer></script><script src="/ts-translate/assets/js/2.a069a211.js" defer></script><script src="/ts-translate/assets/js/27.5cea32b1.js" defer></script>
  </body>
</html>
