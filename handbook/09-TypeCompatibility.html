<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>九、兼容性 | TypeScript手册</title>
    <meta name="description" content="TypeScript 学习手册">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/ts-translate/assets/css/0.styles.0a5bcfed.css" as="style"><link rel="preload" href="/ts-translate/assets/js/app.141fbb0f.js" as="script"><link rel="preload" href="/ts-translate/assets/js/2.a069a211.js" as="script"><link rel="preload" href="/ts-translate/assets/js/26.ece5b4f8.js" as="script"><link rel="prefetch" href="/ts-translate/assets/js/10.06950121.js"><link rel="prefetch" href="/ts-translate/assets/js/11.6381239b.js"><link rel="prefetch" href="/ts-translate/assets/js/12.8176b810.js"><link rel="prefetch" href="/ts-translate/assets/js/13.0a03fbf3.js"><link rel="prefetch" href="/ts-translate/assets/js/14.3482aea1.js"><link rel="prefetch" href="/ts-translate/assets/js/15.7831b050.js"><link rel="prefetch" href="/ts-translate/assets/js/16.2e5641fb.js"><link rel="prefetch" href="/ts-translate/assets/js/17.caa1f0c3.js"><link rel="prefetch" href="/ts-translate/assets/js/18.33f52e19.js"><link rel="prefetch" href="/ts-translate/assets/js/19.8756dd76.js"><link rel="prefetch" href="/ts-translate/assets/js/20.cfed5059.js"><link rel="prefetch" href="/ts-translate/assets/js/21.090f26df.js"><link rel="prefetch" href="/ts-translate/assets/js/22.ff9d5ff1.js"><link rel="prefetch" href="/ts-translate/assets/js/23.9732edd0.js"><link rel="prefetch" href="/ts-translate/assets/js/24.0ce34daf.js"><link rel="prefetch" href="/ts-translate/assets/js/25.240c5ec5.js"><link rel="prefetch" href="/ts-translate/assets/js/27.5cea32b1.js"><link rel="prefetch" href="/ts-translate/assets/js/28.4984b1b2.js"><link rel="prefetch" href="/ts-translate/assets/js/29.6cbf69a3.js"><link rel="prefetch" href="/ts-translate/assets/js/3.572305aa.js"><link rel="prefetch" href="/ts-translate/assets/js/30.21d3e389.js"><link rel="prefetch" href="/ts-translate/assets/js/31.e611e503.js"><link rel="prefetch" href="/ts-translate/assets/js/32.5d9d0c75.js"><link rel="prefetch" href="/ts-translate/assets/js/33.2cb939dd.js"><link rel="prefetch" href="/ts-translate/assets/js/34.f373a061.js"><link rel="prefetch" href="/ts-translate/assets/js/35.9d601f8b.js"><link rel="prefetch" href="/ts-translate/assets/js/36.45e2645f.js"><link rel="prefetch" href="/ts-translate/assets/js/37.ec9011fa.js"><link rel="prefetch" href="/ts-translate/assets/js/38.ecaf875b.js"><link rel="prefetch" href="/ts-translate/assets/js/39.79652b75.js"><link rel="prefetch" href="/ts-translate/assets/js/4.202d41bd.js"><link rel="prefetch" href="/ts-translate/assets/js/40.dfeb8b60.js"><link rel="prefetch" href="/ts-translate/assets/js/41.19371e04.js"><link rel="prefetch" href="/ts-translate/assets/js/42.12a43247.js"><link rel="prefetch" href="/ts-translate/assets/js/43.08babc31.js"><link rel="prefetch" href="/ts-translate/assets/js/5.7ad19b7d.js"><link rel="prefetch" href="/ts-translate/assets/js/6.f507dfa3.js"><link rel="prefetch" href="/ts-translate/assets/js/7.61be865b.js"><link rel="prefetch" href="/ts-translate/assets/js/8.b7b7c55c.js"><link rel="prefetch" href="/ts-translate/assets/js/9.59f9442d.js">
    <link rel="stylesheet" href="/ts-translate/assets/css/0.styles.0a5bcfed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ts-translate/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript手册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/ts-translate/handbook/" class="nav-link router-link-active">
  语法
</a></div><div class="nav-item"><a href="/ts-translate/compilerOptions/" class="nav-link">
  编译选项
</a></div><div class="nav-item"><a href="/ts-translate/declarationFiles/" class="nav-link">
  声明文件
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/ts-translate/handbook/01-Basic.html" class="sidebar-link">一、基本类型</a></li><li><a href="/ts-translate/handbook/02-VariableDecorations.html" class="sidebar-link">二、变量声明</a></li><li><a href="/ts-translate/handbook/03-Interface.html" class="sidebar-link">三、Interface 接口</a></li><li><a href="/ts-translate/handbook/04-Class.html" class="sidebar-link">四、类</a></li><li><a href="/ts-translate/handbook/05-Function.html" class="sidebar-link">五、函数</a></li><li><a href="/ts-translate/handbook/06-Generics.html" class="sidebar-link">六、泛型</a></li><li><a href="/ts-translate/handbook/07-Enums.html" class="sidebar-link">七、枚举</a></li><li><a href="/ts-translate/handbook/08-TypeInference.html" class="sidebar-link">八、类型引用</a></li><li><a href="/ts-translate/handbook/09-TypeCompatibility.html" class="active sidebar-link">九、兼容性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#a-note-on-soundness" class="sidebar-link">A Note on Soundness</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#starting-out" class="sidebar-link">Starting out</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#comparing-two-functions" class="sidebar-link">Comparing two functions</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#function-parameter-bivariance" class="sidebar-link">Function Parameter Bivariance</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#optional-parameters-and-rest-parameters" class="sidebar-link">Optional Parameters and Rest Parameters</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#functions-with-overloads" class="sidebar-link">Functions with overloads</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#enums" class="sidebar-link">Enums</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#classes" class="sidebar-link">Classes</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#private-and-protected-members-in-classes" class="sidebar-link">Private and protected members in classes</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#generics" class="sidebar-link">Generics</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#advanced-topics" class="sidebar-link">Advanced Topics</a></li><li class="sidebar-sub-header"><a href="/ts-translate/handbook/09-TypeCompatibility.html#subtype-vs-assignment" class="sidebar-link">Subtype vs Assignment</a></li></ul></li><li><a href="/ts-translate/handbook/10-AdvanceTypes.html" class="sidebar-link">十、增强类型</a></li><li><a href="/ts-translate/handbook/11-Symbols.html" class="sidebar-link">十一、Symbol</a></li><li><a href="/ts-translate/handbook/12-IteratorAndGenerators.html" class="sidebar-link">十二、可迭代性 Iterables</a></li><li><a href="/ts-translate/handbook/13-Modules.html" class="sidebar-link">十三、模块</a></li><li><a href="/ts-translate/handbook/14-Namespaces.html" class="sidebar-link">十四、命名空间</a></li><li><a href="/ts-translate/handbook/15-NameSpacesModules.html" class="sidebar-link">十五、命名空间与模块</a></li><li><a href="/ts-translate/handbook/16-ModulesResolution.html" class="sidebar-link">十六、模块解析</a></li><li><a href="/ts-translate/handbook/17-DelarationMerging.html" class="sidebar-link">十七、声明合并</a></li><li><a href="/ts-translate/handbook/18-JSX.html" class="sidebar-link">十八、JSX</a></li><li><a href="/ts-translate/handbook/19-Decorators.html" class="sidebar-link">十九、修饰器</a></li><li><a href="/ts-translate/handbook/20-Mixins.html" class="sidebar-link">二十、混入</a></li><li><a href="/ts-translate/handbook/21-TripleSlashDirectives.html" class="sidebar-link">二十一、三斜线指令</a></li><li><a href="/ts-translate/handbook/22-JSDocSupportedTypes.html" class="sidebar-link">二十二、类型检查JavaScript文件</a></li><li><a href="/ts-translate/handbook/23-UtilityTypes.html" class="sidebar-link">二十三、联合类型</a></li><li><a href="/ts-translate/handbook/24-TypescriptIgnore.html" class="sidebar-link">二十四、TypeScript 类型忽略</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="九、兼容性"><a href="#九、兼容性" class="header-anchor">#</a> 九、兼容性</h1> <p>TypeScript中的类型兼容性基于结构子类型。
结构化类型是一种仅基于其成员关联类型的方式。
这与标称键入相反。
考虑以下代码：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p<span class="token operator">:</span> Named<span class="token punctuation">;</span>
<span class="token comment">// OK, because of structural typing</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在诸如C＃或Java之类的名义上的语言中，等效代码将是一个错误，因为<code>Person</code>类并未明确地将自身描述为Named接口的实现者。</p> <p>TypeScript的结构类型系统是根据典型的JavaScript代码编写方式设计的。
由于JavaScript广泛使用诸如函数表达式和对象文字之类的匿名对象，因此使用结构类型系统而不是名义上的类型来表示JavaScript库中的各种关系会更加自然。</p> <h2 id="a-note-on-soundness"><a href="#a-note-on-soundness" class="header-anchor">#</a> A Note on Soundness</h2> <p>TypeScript的类型系统允许某些在编译时未知的操作是安全的。当类型系统具有此属性时，据说它不是“声音”。我们仔细考虑了TypeScript允许不良行为的地方，在本文档中，我们将解释发生这些情况的原因以及背后的动机。</p> <h2 id="starting-out"><a href="#starting-out" class="header-anchor">#</a> Starting out</h2> <p>TypeScript的结构类型系统的基本规则是，如果“ y”至少具有与“ x”相同的成员，则“ x”与“ y”兼容。例如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> x<span class="token operator">:</span> Named<span class="token punctuation">;</span>
<span class="token comment">// y's inferred type is { name: string; location: string; }</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> location<span class="token operator">:</span> <span class="token string">&quot;Seattle&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> y<span class="token punctuation">;</span>
</code></pre></div><p>为了检查是否可以将y赋给x，编译器会检查x的每个属性以在y中找到相应的兼容属性。
在这种情况下，“ y”必须具有一个名为“ name”的成员，该成员是一个字符串。确实如此，因此允许分配。</p> <p>检查函数调用参数时，使用相同的分配规则：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token operator">:</span> Named</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> n<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">greet</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre></div><p>请注意，y具有额外的location属性，但这不会产生错误。
检查兼容性时，仅考虑目标类型的成员（在这种情况下为“命名”）。</p> <p>此比较过程以递归方式进行，探索每个成员和子成员的类型。</p> <h2 id="comparing-two-functions"><a href="#comparing-two-functions" class="header-anchor">#</a> Comparing two functions</h2> <p>尽管比较原始类型和对象类型相对简单，但是涉及哪些类型的功能应该被认为是兼容的。
让我们从两个仅在参数列表上有所不同的函数的基本示例开始：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">b<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> s<span class="token operator">:</span> <span class="token builtin">string</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>

y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// OK</span>
x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>为了检查x是否可分配给y，我们首先看一下参数列表。
x中的每个参数必须在y中具有对应类型的对应参数。
请注意，不考虑参数名称，仅考虑其类型。
在这种情况下，每个x参数在y中都有一个对应的兼容参数，因此允许分配。</p> <p>第二个赋值是一个错误，因为“ y”具有必需的第二个参数，而“ x”没有，因此该赋值是不允许的。</p> <p>您可能想知道为什么我们允许像“ y = x”示例中那样“丢弃”参数。
允许这种分配的原因是，实际上忽略多余的函数参数在JavaScript中是很常见的。
例如，“ Array＃forEach”为回调函数提供了三个参数：数组元素，其索引和包含数组。
不过，提供仅使用第一个参数的回调非常有用：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Don't force these extra parameters</span>
items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Should be OK!</span>
items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在，使用两个仅在返回类型上有所不同的函数，看看如何处理返回类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token function-variable function">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> location<span class="token operator">:</span> <span class="token string">&quot;Seattle&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">// OK</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// Error, because x() lacks a location property</span>
</code></pre></div><p>类型系统强制源函数的返回类型是目标类型的返回类型的子类型。</p> <h2 id="function-parameter-bivariance"><a href="#function-parameter-bivariance" class="header-anchor">#</a> Function Parameter Bivariance</h2> <p>比较功能参数的类型时，如果源参数可分配给目标参数，分配成功，反之亦然。
这是不合理的，因为最终可能会给调用方一个采用更特殊类型的函数的功能，而调用一个较不特殊类型的函数。
实际上，这种错误很少见，允许这种错误会启用许多常见的JavaScript模式。一个简单的例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> EventType <span class="token punctuation">{</span> Mouse<span class="token punctuation">,</span> Keyboard <span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> timestamp<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">MouseEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">KeyEvent</span> <span class="token keyword">extends</span> <span class="token class-name">Event</span> <span class="token punctuation">{</span> keyCode<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">listenEvent</span><span class="token punctuation">(</span>eventType<span class="token operator">:</span> EventType<span class="token punctuation">,</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">n<span class="token operator">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>

<span class="token comment">// Unsound, but useful and common</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token operator">:</span> MouseEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Undesirable alternatives in presence of soundness</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token operator">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token keyword">as</span> MouseEvent<span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>e <span class="token keyword">as</span> MouseEvent<span class="token punctuation">)</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token operator">:</span> MouseEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">&quot;,&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token operator">:</span> Event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span>
<span class="token function">listenEvent</span><span class="token punctuation">(</span>EventType<span class="token punctuation">.</span>Mouse<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过编译器标志<code>strictFunctionTypes</code>可以使TypeScript引发错误。</p> <h2 id="optional-parameters-and-rest-parameters"><a href="#optional-parameters-and-rest-parameters" class="header-anchor">#</a> Optional Parameters and Rest Parameters</h2> <p>比较功能兼容性时，可选参数和必需参数可以互换。
源类型的额外可选参数不是错误，源类型中没有相应参数的目标类型的可选参数也不是错误。</p> <p>当一个函数具有rest参数时，将其视为无限系列的可选参数。</p> <p>从类型系统的角度来看，这是不合理的，但是从运行时的角度来看，可选参数的想法通常没有得到很好的实施，因为在大多数情况下，在该位置传递“ undefined”是等效的。</p> <p>激励示例是函数的常见模式，该函数采用回调并使用一些可预测的（对于程序员）但未知的（对于类型系统）参数来调用它：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">invokeLater</span><span class="token punctuation">(</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... Invoke callback with 'args' ... */</span>
<span class="token punctuation">}</span>

<span class="token comment">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span>
<span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Confusing (x and y are actually required) and undiscoverable</span>
<span class="token function">invokeLater</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">?</span><span class="token punctuation">,</span> y<span class="token operator">?</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">&quot;, &quot;</span> <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="functions-with-overloads"><a href="#functions-with-overloads" class="header-anchor">#</a> Functions with overloads</h2> <p>当函数具有重载时，源类型中的每个重载都必须与目标类型上的兼容签名匹配。
这样可以确保可以在与源函数相同的所有情况下调用目标函数。</p> <h2 id="enums"><a href="#enums" class="header-anchor">#</a> Enums</h2> <p>枚举与数字兼容，而数字与枚举兼容。来自不同枚举类型的枚举值被认为是不兼容的。例如</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">enum</span> Status <span class="token punctuation">{</span> Ready<span class="token punctuation">,</span> Waiting <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> Color <span class="token punctuation">{</span> Red<span class="token punctuation">,</span> Blue<span class="token punctuation">,</span> Green <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> status <span class="token operator">=</span> Status<span class="token punctuation">.</span>Ready<span class="token punctuation">;</span>
status <span class="token operator">=</span> Color<span class="token punctuation">.</span>Green<span class="token punctuation">;</span>  <span class="token comment">// Error</span>
</code></pre></div><h2 id="classes"><a href="#classes" class="header-anchor">#</a> Classes</h2> <p>类与对象文字类型和接口的工作方式类似，但有一个例外：它们既有静态类型又有实例类型。
比较两个类类型的对象时，仅比较实例的成员。
静态成员和构造函数不影响兼容性。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    feet<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> numFeet<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
    feet<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
    <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token parameter">numFeet<span class="token operator">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> a<span class="token operator">:</span> Animal<span class="token punctuation">;</span>
<span class="token keyword">let</span> s<span class="token operator">:</span> Size<span class="token punctuation">;</span>

a <span class="token operator">=</span> s<span class="token punctuation">;</span>  <span class="token comment">// OK</span>
s <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment">// OK</span>
</code></pre></div><h2 id="private-and-protected-members-in-classes"><a href="#private-and-protected-members-in-classes" class="header-anchor">#</a> Private and protected members in classes</h2> <p>类中的私有成员和受保护成员会影响其兼容性。
当检查一个类的实例的兼容性时，如果目标类型包含一个私有成员，那么源类型还必须包含一个源自同一类的私有成员。
同样，对于具有受保护成员的实例也是如此。
这样一来，一个类就可以与其父类进行赋值兼容，但是<em>不能</em>与其他继承层次结构相同的类进行继承。</p> <h2 id="generics"><a href="#generics" class="header-anchor">#</a> Generics</h2> <p>因为TypeScript是结构类型系统，所以类型参数仅在作为成员类型的一部分使用时才影响结果类型。例如，</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Empty</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> x<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span> Empty<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// OK, because y matches structure of x</span>
</code></pre></div><p>在上面，<code>x</code>和<code>y</code>是兼容的，因为它们的结构没有以区别的方式使用type参数。
通过将一个成员添加到<code>Empty &lt;T&gt;</code>来更改此示例，说明了它是如何工作的：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">NotEmpty</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> x<span class="token operator">:</span> NotEmpty<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y<span class="token operator">:</span> NotEmpty<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

x <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment">// Error, because x and y are not compatible</span>
</code></pre></div><p>这样，指定了类型实参的泛型类型就像非泛型类型一样工作。</p> <p>对于未指定类型参数的泛型类型，通过指定“ any”代替所有未指定的类型参数来检查兼容性。
然后，像在非泛型情况下一样，检查结果类型的兼容性。</p> <p>例如，</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token function-variable function">identity</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token function-variable function">reverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">&lt;</span><span class="token constant">U</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>y<span class="token operator">:</span> <span class="token constant">U</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">U</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

identity <span class="token operator">=</span> reverse<span class="token punctuation">;</span>  <span class="token comment">// OK, because (x: any) =&gt; any matches (y: any) =&gt; any</span>
</code></pre></div><h2 id="advanced-topics"><a href="#advanced-topics" class="header-anchor">#</a> Advanced Topics</h2> <h2 id="subtype-vs-assignment"><a href="#subtype-vs-assignment" class="header-anchor">#</a> Subtype vs Assignment</h2> <p>到目前为止，我们已经使用了“兼容”，这不是语言规范中定义的术语。
在TypeScript中，有两种兼容性：子类型和赋值。
它们之间的区别仅在于，赋值扩展了子类型与规则的兼容性，以允许与“任意”以及与“枚举”之间的赋值以及带有相应数值的赋值。</p> <p>语言中的不同位置会根据情况使用两种兼容机制之一。
出于实际目的，类型兼容性由分配兼容性决定，即使在<code>implements</code>和<code>extends</code>子句的情况下也是如此。</p> <p>有关更多信息，请参见<a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" target="_blank" rel="noopener noreferrer">TypeScript规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/7/2020, 3:48:55 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ts-translate/handbook/08-TypeInference.html" class="prev">
        八、类型引用
      </a></span> <span class="next"><a href="/ts-translate/handbook/10-AdvanceTypes.html">
        十、增强类型
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ts-translate/assets/js/app.141fbb0f.js" defer></script><script src="/ts-translate/assets/js/2.a069a211.js" defer></script><script src="/ts-translate/assets/js/26.ece5b4f8.js" defer></script>
  </body>
</html>
